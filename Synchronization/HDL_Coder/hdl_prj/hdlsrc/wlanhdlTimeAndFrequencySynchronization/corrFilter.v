// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/wlanhdlTimeAndFrequencySynchronization/corrFilter.v
// Created: 2026-02-04 22:38:44
// 
// Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: corrFilter
// Source Path: wlanhdlTimeAndFrequencySynchronization/WLANTimeAndFrequencySynchronization/Fine Time Sync/Correlator/corrFilter
// Hierarchy Level: 3
// Model version: 9.2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module corrFilter
          (clk,
           reset,
           enb_1_8_1,
           enb_1_8_0,
           enb,
           enb_1_1_1,
           dataIn_re,
           dataIn_im,
           validIn,
           rst,
           dataOut_re,
           dataOut_im,
           validOut);


  input   clk;
  input   reset;
  input   enb_1_8_1;
  input   enb_1_8_0;
  input   enb;
  input   enb_1_1_1;
  input   signed [15:0] dataIn_re;  // sfix16_En12
  input   signed [15:0] dataIn_im;  // sfix16_En12
  input   validIn;
  input   rst;
  output  signed [36:0] dataOut_re;  // sfix37_En26
  output  signed [36:0] dataOut_im;  // sfix37_En26
  output  validOut;


  wire signed [15:0] Upsample_zero_re;  // sfix16_En12
  wire signed [15:0] Upsample_zero_im;  // sfix16_En12
  wire signed [15:0] Upsample_muxout_re;  // sfix16_En12
  wire signed [15:0] Upsample_muxout_im;  // sfix16_En12
  reg signed [15:0] Upsample_bypass_reg_re;  // sfix16_En12
  reg signed [15:0] Upsample_bypass_reg_im;  // sfix16_En12
  wire signed [15:0] Upsample_bypassout_re;  // sfix16_En12
  wire signed [15:0] Upsample_bypassout_im;  // sfix16_En12
  wire Upsample1_zero;
  wire Upsample1_muxout;
  reg  Upsample1_bypass_reg;  // ufix1
  wire Upsample1_bypassout;
  wire Upsample2_zero;
  wire Upsample2_muxout;
  reg  Upsample2_bypass_reg;  // ufix1
  wire Upsample2_bypassout;
  wire signed [36:0] C1_out1_re;  // sfix37_En26
  wire signed [36:0] C1_out1_im;  // sfix37_En26
  wire C1_out2;
  reg signed [36:0] Delay_reg_re [0:6];  // sfix37_En26 [7]
  reg signed [36:0] Delay_reg_im [0:6];  // sfix37_En26 [7]
  reg signed [36:0] Delay_reg_next_re [0:6];  // sfix37_En26 [7]
  reg signed [36:0] Delay_reg_next_im [0:6];  // sfix37_En26 [7]
  reg signed [36:0] Delay_out1_re;  // sfix37_En26
  reg signed [36:0] Delay_out1_im;  // sfix37_En26
  reg signed [36:0] Downsample_out1_re;  // sfix37_En26
  reg signed [36:0] Downsample_out1_im;  // sfix37_En26
  reg signed [36:0] Downsample_out1_re_1;  // sfix37_En26
  reg signed [36:0] Downsample_out1_im_1;  // sfix37_En26
  reg  [6:0] Delay1_reg;  // ufix1 [7]
  wire Delay1_out1;
  reg  Downsample1_out1;
  reg  Downsample1_out1_1;
  reg signed [31:0] Delay_t_0_0;  // int32
  reg signed [31:0] Delay_t_0_1;  // int32
  reg signed [31:0] Delay_t_1;  // int32

  // delayLen=filterUpsampleFactor-1
  // Latency = (coeffLen/filterUpsampleFactor)+filterUpsampleFactor+9


  assign Upsample_zero_re = 16'sb0000000000000000;
  assign Upsample_zero_im = 16'sb0000000000000000;

  // Upsample: Upsample by 8, Sample offset 0 
  assign Upsample_muxout_re = (enb_1_8_1 == 1'b1 ? dataIn_re :
              Upsample_zero_re);
  assign Upsample_muxout_im = (enb_1_8_1 == 1'b1 ? dataIn_im :
              Upsample_zero_im);

  // Upsample bypass register
  always @(posedge clk or posedge reset)
    begin : Upsample_bypass_process
      if (reset == 1'b1) begin
        Upsample_bypass_reg_re <= 16'sb0000000000000000;
        Upsample_bypass_reg_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_1_1) begin
          Upsample_bypass_reg_im <= Upsample_muxout_im;
          Upsample_bypass_reg_re <= Upsample_muxout_re;
        end
      end
    end

  assign Upsample_bypassout_re = (enb_1_1_1 == 1'b1 ? Upsample_muxout_re :
              Upsample_bypass_reg_re);
  assign Upsample_bypassout_im = (enb_1_1_1 == 1'b1 ? Upsample_muxout_im :
              Upsample_bypass_reg_im);

  assign Upsample1_zero = 1'b0;

  // Upsample1: Upsample by 8, Sample offset 0 
  assign Upsample1_muxout = (enb_1_8_1 == 1'b1 ? validIn :
              Upsample1_zero);

  // Upsample bypass register
  always @(posedge clk or posedge reset)
    begin : Upsample1_bypass_process
      if (reset == 1'b1) begin
        Upsample1_bypass_reg <= 1'b0;
      end
      else begin
        if (enb_1_1_1) begin
          Upsample1_bypass_reg <= Upsample1_muxout;
        end
      end
    end

  assign Upsample1_bypassout = (enb_1_1_1 == 1'b1 ? Upsample1_muxout :
              Upsample1_bypass_reg);

  assign Upsample2_zero = 1'b0;

  // Upsample2: Upsample by 8, Sample offset 0 
  assign Upsample2_muxout = (enb_1_8_1 == 1'b1 ? rst :
              Upsample2_zero);

  // Upsample bypass register
  always @(posedge clk or posedge reset)
    begin : Upsample2_bypass_process
      if (reset == 1'b1) begin
        Upsample2_bypass_reg <= 1'b0;
      end
      else begin
        if (enb_1_1_1) begin
          Upsample2_bypass_reg <= Upsample2_muxout;
        end
      end
    end

  assign Upsample2_bypassout = (enb_1_1_1 == 1'b1 ? Upsample2_muxout :
              Upsample2_bypass_reg);

  C1 u_C1 (.clk(clk),
           .reset(reset),
           .enb(enb),
           .dataIn_re(Upsample_bypassout_re),  // sfix16_En12
           .dataIn_im(Upsample_bypassout_im),  // sfix16_En12
           .validIn(Upsample1_bypassout),
           .syncReset(Upsample2_bypassout),
           .dataOut_re(C1_out1_re),  // sfix37_En26
           .dataOut_im(C1_out1_im),  // sfix37_En26
           .validOut(C1_out2)
           );

  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        for(Delay_t_1 = 32'sd0; Delay_t_1 <= 32'sd6; Delay_t_1 = Delay_t_1 + 32'sd1) begin
          Delay_reg_re[Delay_t_1] <= 37'sh0000000000;
          Delay_reg_im[Delay_t_1] <= 37'sh0000000000;
        end
      end
      else begin
        if (enb) begin
          for(Delay_t_0_1 = 32'sd0; Delay_t_0_1 <= 32'sd6; Delay_t_0_1 = Delay_t_0_1 + 32'sd1) begin
            Delay_reg_re[Delay_t_0_1] <= Delay_reg_next_re[Delay_t_0_1];
            Delay_reg_im[Delay_t_0_1] <= Delay_reg_next_im[Delay_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay_out1_re = Delay_reg_re[6];
    Delay_out1_im = Delay_reg_im[6];
    Delay_reg_next_re[0] = C1_out1_re;
    Delay_reg_next_im[0] = C1_out1_im;

    for(Delay_t_0_0 = 32'sd0; Delay_t_0_0 <= 32'sd5; Delay_t_0_0 = Delay_t_0_0 + 32'sd1) begin
      Delay_reg_next_re[Delay_t_0_0 + 32'sd1] = Delay_reg_re[Delay_t_0_0];
      Delay_reg_next_im[Delay_t_0_0 + 32'sd1] = Delay_reg_im[Delay_t_0_0];
    end

  end

  // Downsample by 8 register (Sample offset 0)
  always @(posedge clk or posedge reset)
    begin : Downsample_output_process
      if (reset == 1'b1) begin
        Downsample_out1_re <= 37'sh0000000000;
        Downsample_out1_im <= 37'sh0000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Downsample_out1_re <= Delay_out1_re;
          Downsample_out1_im <= Delay_out1_im;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : PipelineRegister1_process
      if (reset == 1'b1) begin
        Downsample_out1_re_1 <= 37'sh0000000000;
        Downsample_out1_im_1 <= 37'sh0000000000;
      end
      else begin
        if (enb_1_8_0) begin
          Downsample_out1_re_1 <= Downsample_out1_re;
          Downsample_out1_im_1 <= Downsample_out1_im;
        end
      end
    end

  assign dataOut_re = Downsample_out1_re_1;

  assign dataOut_im = Downsample_out1_im_1;

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_reg <= {7{1'b0}};
      end
      else begin
        if (enb) begin
          Delay1_reg[0] <= C1_out2;
          Delay1_reg[32'sd6:32'sd1] <= Delay1_reg[32'sd5:32'sd0];
        end
      end
    end

  assign Delay1_out1 = Delay1_reg[6];

  // Downsample by 8 register (Sample offset 0)
  always @(posedge clk or posedge reset)
    begin : Downsample1_output_process
      if (reset == 1'b1) begin
        Downsample1_out1 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Downsample1_out1 <= Delay1_out1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : PipelineRegister_process
      if (reset == 1'b1) begin
        Downsample1_out1_1 <= 1'b0;
      end
      else begin
        if (enb_1_8_0) begin
          Downsample1_out1_1 <= Downsample1_out1;
        end
      end
    end

  assign validOut = Downsample1_out1_1;

endmodule  // corrFilter

