// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/wlanhdlTimeAndFrequencySynchronization/Correlator_block1.v
// Created: 2026-02-04 22:38:44
// 
// Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Correlator_block1
// Source Path: wlanhdlTimeAndFrequencySynchronization/WLANTimeAndFrequencySynchronization/Fine CFO Estimation and 
// Correction/Fine CFO Estimation/Correlato
// Hierarchy Level: 3
// Model version: 9.2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Correlator_block1
          (clk,
           reset,
           enb_1_8_1,
           enb_1_8_0,
           enb,
           dataIn_re,
           dataIn_im,
           corrOut_re,
           corrOut_im);


  input   clk;
  input   reset;
  input   enb_1_8_1;
  input   enb_1_8_0;
  input   enb;
  input   signed [15:0] dataIn_re;  // sfix16_En12
  input   signed [15:0] dataIn_im;  // sfix16_En12
  output  signed [30:0] corrOut_re;  // sfix31_En19
  output  signed [30:0] corrOut_im;  // sfix31_En19


  reg signed [15:0] rd_0_reg_re [0:1];  // sfix16_En12 [2]
  reg signed [15:0] rd_0_reg_im [0:1];  // sfix16_En12 [2]
  wire signed [15:0] rd_0_reg_next_re [0:1];  // sfix16_En12 [2]
  wire signed [15:0] rd_0_reg_next_im [0:1];  // sfix16_En12 [2]
  wire signed [15:0] Data_Type_Conversion1_out1_re;  // sfix16_En12
  wire signed [15:0] Data_Type_Conversion1_out1_im;  // sfix16_En12
  wire signed [15:0] Delay1_out1_re;  // sfix16_En12
  wire signed [15:0] Delay1_out1_im;  // sfix16_En12
  reg signed [15:0] Delay1_out1_re_1;  // sfix16_En12
  reg signed [15:0] Delay1_out1_im_1;  // sfix16_En12
  reg signed [15:0] Product_C2ReIm_1_C2ReIm_A;  // sfix16_En12
  wire [31:0] mergedInput;  // ufix32
  reg [31:0] mergedDelay_regin;  // ufix32
  reg [5:0] mergedDelay_waddr;  // ufix6
  wire mergedDelay_wrenb;  // ufix1
  reg [5:0] mergedDelay_raddr;  // ufix6
  wire [31:0] mergedDelay_regout;  // ufix32
  reg [31:0] mergedOutput;  // ufix32
  wire [15:0] slicedInput;  // ufix16
  wire signed [15:0] realOutput;  // sfix16_En12
  wire [15:0] slicedInput_1;  // ufix16
  wire signed [15:0] imagOutput;  // sfix16_En12
  wire signed [16:0] conj_cast;  // sfix17_En12
  wire signed [16:0] conj_cast_1;  // sfix17_En12
  wire signed [15:0] complexConj_out1_re;  // sfix16_En12
  wire signed [15:0] complexConj_out1_im;  // sfix16_En12
  reg signed [15:0] rd_3_reg_re [0:1];  // sfix16_En12 [2]
  reg signed [15:0] rd_3_reg_im [0:1];  // sfix16_En12 [2]
  wire signed [15:0] rd_3_reg_next_re [0:1];  // sfix16_En12 [2]
  wire signed [15:0] rd_3_reg_next_im [0:1];  // sfix16_En12 [2]
  wire signed [15:0] complexConj_out1_re_1;  // sfix16_En12
  wire signed [15:0] complexConj_out1_im_1;  // sfix16_En12
  wire signed [15:0] Delay3_out1_re;  // sfix16_En12
  wire signed [15:0] Delay3_out1_im;  // sfix16_En12
  reg signed [15:0] Delay3_out1_re_1;  // sfix16_En12
  reg signed [15:0] Delay3_out1_im_1;  // sfix16_En12
  reg signed [15:0] Product_C2ReIm_2_C2ReIm_A;  // sfix16_En12
  wire signed [31:0] Product_Re_AC;  // sfix32_En24
  reg signed [31:0] HwModeRegister_reg [0:2];  // sfix32 [3]
  reg signed [31:0] HwModeRegister_reg_next [0:2];  // sfix32_En24 [3]
  reg signed [31:0] Product_Re_AC_1;  // sfix32_En24
  reg signed [15:0] rd_2_reg [0:1];  // sfix16 [2]
  wire signed [15:0] rd_2_reg_next [0:1];  // sfix16_En12 [2]
  wire signed [15:0] Product_C2ReIm_1_C2ReIm_B;  // sfix16_En12
  reg signed [15:0] Product_C2ReIm_1_C2ReIm_B_1;  // sfix16_En12
  reg signed [15:0] Product_C2ReIm_2_C2ReIm_B;  // sfix16_En12
  reg signed [15:0] reduced_reg [0:1];  // sfix16 [2]
  wire signed [15:0] reduced_reg_next [0:1];  // sfix16_En12 [2]
  wire signed [15:0] Product_C2ReIm_2_C2ReIm_B_1;  // sfix16_En12
  (* use_dsp  = "yes" *)   wire signed [31:0] mulOutput;  // sfix32_En24
  reg signed [31:0] mulOutput_1;  // sfix32_En24
  wire signed [32:0] MultiplyAdd_add_sub_cast;  // sfix33_En24
  wire signed [32:0] MultiplyAdd_add_sub_cast_1;  // sfix33_En24
  wire signed [32:0] mulOutput_2;  // sfix33_En24
  wire signed [31:0] Product_Im_AD;  // sfix32_En24
  reg signed [31:0] HwModeRegister_reg_1 [0:2];  // sfix32 [3]
  reg signed [31:0] HwModeRegister_reg_next_1 [0:2];  // sfix32_En24 [3]
  reg signed [31:0] Product_Im_AD_1;  // sfix32_En24
  reg signed [15:0] reduced_reg_1 [0:1];  // sfix16 [2]
  wire signed [15:0] reduced_reg_next_1 [0:1];  // sfix16_En12 [2]
  wire signed [15:0] Product_C2ReIm_2_C2ReIm_A_1;  // sfix16_En12
  (* use_dsp  = "yes" *)   wire signed [31:0] mulOutput_3;  // sfix32_En24
  reg signed [31:0] mulOutput_4;  // sfix32_En24
  wire signed [32:0] MultiplyAdd1_add_add_cast;  // sfix33_En24
  wire signed [32:0] MultiplyAdd1_add_add_cast_1;  // sfix33_En24
  wire signed [32:0] mulOutput_5;  // sfix33_En24
  reg signed [32:0] rd_7_reg [0:1];  // sfix33 [2]
  wire signed [32:0] rd_7_reg_next [0:1];  // sfix33_En24 [2]
  wire signed [32:0] mulOutput_6;  // sfix33_En24
  wire signed [31:0] mulOutput_7;  // sfix32_En24
  reg signed [32:0] rd_8_reg [0:1];  // sfix33 [2]
  wire signed [32:0] rd_8_reg_next [0:1];  // sfix33_En24 [2]
  wire signed [32:0] mulOutput_8;  // sfix33_En24
  wire signed [31:0] mulOutput_9;  // sfix32_En24
  reg signed [31:0] Product_out1_re;  // sfix32_En24
  reg signed [31:0] Product_out1_im;  // sfix32_En24
  reg signed [31:0] Delay32_bypass_reg_re;  // sfix32_En24
  reg signed [31:0] Delay32_bypass_reg_im;  // sfix32_En24
  wire signed [31:0] Delay32_out1_re;  // sfix32_En24
  wire signed [31:0] Delay32_out1_im;  // sfix32_En24
  wire signed [31:0] Delay32_out1_re_1;  // sfix32_En24
  wire signed [31:0] Delay32_out1_im_1;  // sfix32_En24
  reg signed [31:0] Delay32_out1_re_2;  // sfix32_En24
  reg signed [31:0] Delay32_out1_im_2;  // sfix32_En24
  wire signed [30:0] Data_Type_Conversion_out1_re;  // sfix31_En19
  wire signed [30:0] Data_Type_Conversion_out1_im;  // sfix31_En19
  reg signed [31:0] rd_0_t_0_0;  // int32
  reg signed [31:0] rd_0_t_1;  // int32
  reg signed [31:0] rd_3_t_0_0;  // int32
  reg signed [31:0] rd_3_t_1;  // int32
  reg signed [31:0] HwModeRegister_t_0_0;  // int32
  reg signed [31:0] HwModeRegister_t_0_1;  // int32
  reg signed [31:0] HwModeRegister_t_1;  // int32
  reg signed [31:0] rd_2_t_0_0;  // int32
  reg signed [31:0] rd_2_t_1;  // int32
  reg signed [31:0] reduced_t_0_0;  // int32
  reg signed [31:0] reduced_t_1;  // int32
  reg signed [31:0] HwModeRegister_t_0_0_1;  // int32
  reg signed [31:0] HwModeRegister_t_0_1_1;  // int32
  reg signed [31:0] HwModeRegister_t_1_1;  // int32
  reg signed [31:0] reduced_t_0_0_1;  // int32
  reg signed [31:0] reduced_t_1_1;  // int32
  reg signed [31:0] rd_7_t_0_0;  // int32
  reg signed [31:0] rd_7_t_1;  // int32
  reg signed [31:0] rd_8_t_0_0;  // int32
  reg signed [31:0] rd_8_t_1;  // int32


  always @(posedge clk or posedge reset)
    begin : rd_0_process
      if (reset == 1'b1) begin
        for(rd_0_t_1 = 32'sd0; rd_0_t_1 <= 32'sd1; rd_0_t_1 = rd_0_t_1 + 32'sd1) begin
          rd_0_reg_re[rd_0_t_1] <= 16'sb0000000000000000;
          rd_0_reg_im[rd_0_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb_1_8_0) begin
          for(rd_0_t_0_0 = 32'sd0; rd_0_t_0_0 <= 32'sd1; rd_0_t_0_0 = rd_0_t_0_0 + 32'sd1) begin
            rd_0_reg_re[rd_0_t_0_0] <= rd_0_reg_next_re[rd_0_t_0_0];
            rd_0_reg_im[rd_0_t_0_0] <= rd_0_reg_next_im[rd_0_t_0_0];
          end
        end
      end
    end

  assign Data_Type_Conversion1_out1_re = rd_0_reg_re[1];
  assign Data_Type_Conversion1_out1_im = rd_0_reg_im[1];
  assign rd_0_reg_next_re[0] = dataIn_re;
  assign rd_0_reg_next_im[0] = dataIn_im;
  assign rd_0_reg_next_re[1] = rd_0_reg_re[0];
  assign rd_0_reg_next_im[1] = rd_0_reg_im[0];

  assign Delay1_out1_re = Data_Type_Conversion1_out1_re;

  assign Delay1_out1_im = Data_Type_Conversion1_out1_im;

  always @(posedge clk or posedge reset)
    begin : rd_1_process
      if (reset == 1'b1) begin
        Delay1_out1_re_1 <= 16'sb0000000000000000;
        Delay1_out1_im_1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay1_out1_re_1 <= Delay1_out1_re;
          Delay1_out1_im_1 <= Delay1_out1_im;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : reduced_process
      if (reset == 1'b1) begin
        Product_C2ReIm_1_C2ReIm_A <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Product_C2ReIm_1_C2ReIm_A <= Delay1_out1_re_1;
        end
      end
    end

  assign mergedInput = {dataIn_re, dataIn_im};

  // Input register for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_reginc_process
      if (reset == 1'b1) begin
        mergedDelay_regin <= 32'b00000000000000000000000000000000;
      end
      else begin
        if (enb_1_8_0) begin
          mergedDelay_regin <= mergedInput;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 61
  // Write address counter for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_wr_process
      if (reset == 1'b1) begin
        mergedDelay_waddr <= 6'b000000;
      end
      else begin
        if (enb_1_8_0) begin
          if (mergedDelay_waddr >= 6'b111101) begin
            mergedDelay_waddr <= 6'b000000;
          end
          else begin
            mergedDelay_waddr <= mergedDelay_waddr + 6'b000001;
          end
        end
      end
    end

  assign mergedDelay_wrenb = 1'b1;

  // Count limited, Unsigned Counter
  //  initial value   = 1
  //  step value      = 1
  //  count to value  = 61
  // Read address counter for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_rd_process
      if (reset == 1'b1) begin
        mergedDelay_raddr <= 6'b000001;
      end
      else begin
        if (enb_1_8_0) begin
          if (mergedDelay_raddr >= 6'b111101) begin
            mergedDelay_raddr <= 6'b000000;
          end
          else begin
            mergedDelay_raddr <= mergedDelay_raddr + 6'b000001;
          end
        end
      end
    end

  SimpleDualPortRAM_generic #(.AddrWidth(6),
                              .DataWidth(32)
                              )
                            u_ShiftRegisterRAM (.clk(clk),
                                                .enb_1_8_0(enb_1_8_0),
                                                .wr_din(mergedDelay_regin),
                                                .wr_addr(mergedDelay_waddr),
                                                .wr_en(mergedDelay_wrenb),  // ufix1
                                                .rd_addr(mergedDelay_raddr),
                                                .dout(mergedDelay_regout)
                                                );

  // Output register for RAM-based shift register mergedDelay
  always @(posedge clk or posedge reset)
    begin : mergedDelay_regoutc_process
      if (reset == 1'b1) begin
        mergedOutput <= 32'b00000000000000000000000000000000;
      end
      else begin
        if (enb_1_8_0) begin
          mergedOutput <= mergedDelay_regout;
        end
      end
    end

  assign slicedInput = mergedOutput[31:16];

  assign realOutput = slicedInput;

  assign slicedInput_1 = mergedOutput[15:0];

  assign imagOutput = slicedInput_1;

  assign complexConj_out1_re = realOutput;
  assign conj_cast = {imagOutput[15], imagOutput};
  assign conj_cast_1 =  - (conj_cast);
  assign complexConj_out1_im = conj_cast_1[15:0];

  always @(posedge clk or posedge reset)
    begin : rd_3_process
      if (reset == 1'b1) begin
        for(rd_3_t_1 = 32'sd0; rd_3_t_1 <= 32'sd1; rd_3_t_1 = rd_3_t_1 + 32'sd1) begin
          rd_3_reg_re[rd_3_t_1] <= 16'sb0000000000000000;
          rd_3_reg_im[rd_3_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb_1_8_0) begin
          for(rd_3_t_0_0 = 32'sd0; rd_3_t_0_0 <= 32'sd1; rd_3_t_0_0 = rd_3_t_0_0 + 32'sd1) begin
            rd_3_reg_re[rd_3_t_0_0] <= rd_3_reg_next_re[rd_3_t_0_0];
            rd_3_reg_im[rd_3_t_0_0] <= rd_3_reg_next_im[rd_3_t_0_0];
          end
        end
      end
    end

  assign complexConj_out1_re_1 = rd_3_reg_re[1];
  assign complexConj_out1_im_1 = rd_3_reg_im[1];
  assign rd_3_reg_next_re[0] = complexConj_out1_re;
  assign rd_3_reg_next_im[0] = complexConj_out1_im;
  assign rd_3_reg_next_re[1] = rd_3_reg_re[0];
  assign rd_3_reg_next_im[1] = rd_3_reg_im[0];

  assign Delay3_out1_re = complexConj_out1_re_1;

  assign Delay3_out1_im = complexConj_out1_im_1;

  always @(posedge clk or posedge reset)
    begin : rd_4_process
      if (reset == 1'b1) begin
        Delay3_out1_re_1 <= 16'sb0000000000000000;
        Delay3_out1_im_1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay3_out1_re_1 <= Delay3_out1_re;
          Delay3_out1_im_1 <= Delay3_out1_im;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : reduced_1_process
      if (reset == 1'b1) begin
        Product_C2ReIm_2_C2ReIm_A <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Product_C2ReIm_2_C2ReIm_A <= Delay3_out1_re_1;
        end
      end
    end

  assign Product_Re_AC = Product_C2ReIm_1_C2ReIm_A * Product_C2ReIm_2_C2ReIm_A;

  always @(posedge clk or posedge reset)
    begin : HwModeRegister_process
      if (reset == 1'b1) begin
        for(HwModeRegister_t_1 = 32'sd0; HwModeRegister_t_1 <= 32'sd2; HwModeRegister_t_1 = HwModeRegister_t_1 + 32'sd1) begin
          HwModeRegister_reg[HwModeRegister_t_1] <= 32'sb00000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister_t_0_1 = 32'sd0; HwModeRegister_t_0_1 <= 32'sd2; HwModeRegister_t_0_1 = HwModeRegister_t_0_1 + 32'sd1) begin
            HwModeRegister_reg[HwModeRegister_t_0_1] <= HwModeRegister_reg_next[HwModeRegister_t_0_1];
          end
        end
      end
    end

  always @* begin
    Product_Re_AC_1 = HwModeRegister_reg[2];
    HwModeRegister_reg_next[0] = Product_Re_AC;

    for(HwModeRegister_t_0_0 = 32'sd0; HwModeRegister_t_0_0 <= 32'sd1; HwModeRegister_t_0_0 = HwModeRegister_t_0_0 + 32'sd1) begin
      HwModeRegister_reg_next[HwModeRegister_t_0_0 + 32'sd1] = HwModeRegister_reg[HwModeRegister_t_0_0];
    end

  end

  always @(posedge clk or posedge reset)
    begin : rd_2_process
      if (reset == 1'b1) begin
        for(rd_2_t_1 = 32'sd0; rd_2_t_1 <= 32'sd1; rd_2_t_1 = rd_2_t_1 + 32'sd1) begin
          rd_2_reg[rd_2_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_2_t_0_0 = 32'sd0; rd_2_t_0_0 <= 32'sd1; rd_2_t_0_0 = rd_2_t_0_0 + 32'sd1) begin
            rd_2_reg[rd_2_t_0_0] <= rd_2_reg_next[rd_2_t_0_0];
          end
        end
      end
    end

  assign Product_C2ReIm_1_C2ReIm_B = rd_2_reg[1];
  assign rd_2_reg_next[0] = Delay1_out1_im_1;
  assign rd_2_reg_next[1] = rd_2_reg[0];

  always @(posedge clk or posedge reset)
    begin : reduced_2_process
      if (reset == 1'b1) begin
        Product_C2ReIm_1_C2ReIm_B_1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Product_C2ReIm_1_C2ReIm_B_1 <= Product_C2ReIm_1_C2ReIm_B;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : reduced_3_process
      if (reset == 1'b1) begin
        Product_C2ReIm_2_C2ReIm_B <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Product_C2ReIm_2_C2ReIm_B <= Delay3_out1_im_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : reduced_4_process
      if (reset == 1'b1) begin
        for(reduced_t_1 = 32'sd0; reduced_t_1 <= 32'sd1; reduced_t_1 = reduced_t_1 + 32'sd1) begin
          reduced_reg[reduced_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(reduced_t_0_0 = 32'sd0; reduced_t_0_0 <= 32'sd1; reduced_t_0_0 = reduced_t_0_0 + 32'sd1) begin
            reduced_reg[reduced_t_0_0] <= reduced_reg_next[reduced_t_0_0];
          end
        end
      end
    end

  assign Product_C2ReIm_2_C2ReIm_B_1 = reduced_reg[1];
  assign reduced_reg_next[0] = Product_C2ReIm_2_C2ReIm_B;
  assign reduced_reg_next[1] = reduced_reg[0];

  assign mulOutput = Product_C2ReIm_1_C2ReIm_B_1 * Product_C2ReIm_2_C2ReIm_B_1;

  always @(posedge clk or posedge reset)
    begin : HwModeRegister_1_process
      if (reset == 1'b1) begin
        mulOutput_1 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mulOutput_1 <= mulOutput;
        end
      end
    end

  assign MultiplyAdd_add_sub_cast = {Product_Re_AC_1[31], Product_Re_AC_1};
  assign MultiplyAdd_add_sub_cast_1 = {mulOutput_1[31], mulOutput_1};
  assign mulOutput_2 = MultiplyAdd_add_sub_cast - MultiplyAdd_add_sub_cast_1;

  assign Product_Im_AD = Product_C2ReIm_1_C2ReIm_A * Product_C2ReIm_2_C2ReIm_B;

  always @(posedge clk or posedge reset)
    begin : HwModeRegister_2_process
      if (reset == 1'b1) begin
        for(HwModeRegister_t_1_1 = 32'sd0; HwModeRegister_t_1_1 <= 32'sd2; HwModeRegister_t_1_1 = HwModeRegister_t_1_1 + 32'sd1) begin
          HwModeRegister_reg_1[HwModeRegister_t_1_1] <= 32'sb00000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister_t_0_1_1 = 32'sd0; HwModeRegister_t_0_1_1 <= 32'sd2; HwModeRegister_t_0_1_1 = HwModeRegister_t_0_1_1 + 32'sd1) begin
            HwModeRegister_reg_1[HwModeRegister_t_0_1_1] <= HwModeRegister_reg_next_1[HwModeRegister_t_0_1_1];
          end
        end
      end
    end

  always @* begin
    Product_Im_AD_1 = HwModeRegister_reg_1[2];
    HwModeRegister_reg_next_1[0] = Product_Im_AD;

    for(HwModeRegister_t_0_0_1 = 32'sd0; HwModeRegister_t_0_0_1 <= 32'sd1; HwModeRegister_t_0_0_1 = HwModeRegister_t_0_0_1 + 32'sd1) begin
      HwModeRegister_reg_next_1[HwModeRegister_t_0_0_1 + 32'sd1] = HwModeRegister_reg_1[HwModeRegister_t_0_0_1];
    end

  end

  always @(posedge clk or posedge reset)
    begin : reduced_5_process
      if (reset == 1'b1) begin
        for(reduced_t_1_1 = 32'sd0; reduced_t_1_1 <= 32'sd1; reduced_t_1_1 = reduced_t_1_1 + 32'sd1) begin
          reduced_reg_1[reduced_t_1_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(reduced_t_0_0_1 = 32'sd0; reduced_t_0_0_1 <= 32'sd1; reduced_t_0_0_1 = reduced_t_0_0_1 + 32'sd1) begin
            reduced_reg_1[reduced_t_0_0_1] <= reduced_reg_next_1[reduced_t_0_0_1];
          end
        end
      end
    end

  assign Product_C2ReIm_2_C2ReIm_A_1 = reduced_reg_1[1];
  assign reduced_reg_next_1[0] = Product_C2ReIm_2_C2ReIm_A;
  assign reduced_reg_next_1[1] = reduced_reg_1[0];

  assign mulOutput_3 = Product_C2ReIm_1_C2ReIm_B_1 * Product_C2ReIm_2_C2ReIm_A_1;

  always @(posedge clk or posedge reset)
    begin : HwModeRegister_3_process
      if (reset == 1'b1) begin
        mulOutput_4 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mulOutput_4 <= mulOutput_3;
        end
      end
    end

  assign MultiplyAdd1_add_add_cast = {Product_Im_AD_1[31], Product_Im_AD_1};
  assign MultiplyAdd1_add_add_cast_1 = {mulOutput_4[31], mulOutput_4};
  assign mulOutput_5 = MultiplyAdd1_add_add_cast + MultiplyAdd1_add_add_cast_1;

  always @(posedge clk or posedge reset)
    begin : rd_7_process
      if (reset == 1'b1) begin
        for(rd_7_t_1 = 32'sd0; rd_7_t_1 <= 32'sd1; rd_7_t_1 = rd_7_t_1 + 32'sd1) begin
          rd_7_reg[rd_7_t_1] <= 33'sh000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_7_t_0_0 = 32'sd0; rd_7_t_0_0 <= 32'sd1; rd_7_t_0_0 = rd_7_t_0_0 + 32'sd1) begin
            rd_7_reg[rd_7_t_0_0] <= rd_7_reg_next[rd_7_t_0_0];
          end
        end
      end
    end

  assign mulOutput_6 = rd_7_reg[1];
  assign rd_7_reg_next[0] = mulOutput_2;
  assign rd_7_reg_next[1] = rd_7_reg[0];

  assign mulOutput_7 = mulOutput_6[31:0];

  always @(posedge clk or posedge reset)
    begin : rd_8_process
      if (reset == 1'b1) begin
        for(rd_8_t_1 = 32'sd0; rd_8_t_1 <= 32'sd1; rd_8_t_1 = rd_8_t_1 + 32'sd1) begin
          rd_8_reg[rd_8_t_1] <= 33'sh000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_8_t_0_0 = 32'sd0; rd_8_t_0_0 <= 32'sd1; rd_8_t_0_0 = rd_8_t_0_0 + 32'sd1) begin
            rd_8_reg[rd_8_t_0_0] <= rd_8_reg_next[rd_8_t_0_0];
          end
        end
      end
    end

  assign mulOutput_8 = rd_8_reg[1];
  assign rd_8_reg_next[0] = mulOutput_5;
  assign rd_8_reg_next[1] = rd_8_reg[0];

  assign mulOutput_9 = mulOutput_8[31:0];

  always @(posedge clk or posedge reset)
    begin : rd_9_process
      if (reset == 1'b1) begin
        Product_out1_re <= 32'sb00000000000000000000000000000000;
        Product_out1_im <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Product_out1_re <= mulOutput_7;
          Product_out1_im <= mulOutput_9;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay32_bypass_process
      if (reset == 1'b1) begin
        Delay32_bypass_reg_re <= 32'sb00000000000000000000000000000000;
        Delay32_bypass_reg_im <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Delay32_bypass_reg_im <= Product_out1_im;
          Delay32_bypass_reg_re <= Product_out1_re;
        end
      end
    end

  assign Delay32_out1_re = (enb_1_8_1 == 1'b1 ? Product_out1_re :
              Delay32_bypass_reg_re);
  assign Delay32_out1_im = (enb_1_8_1 == 1'b1 ? Product_out1_im :
              Delay32_bypass_reg_im);

  assign Delay32_out1_re_1 = Delay32_out1_re;

  assign Delay32_out1_im_1 = Delay32_out1_im;

  always @(posedge clk or posedge reset)
    begin : rd_10_process
      if (reset == 1'b1) begin
        Delay32_out1_re_2 <= 32'sb00000000000000000000000000000000;
        Delay32_out1_im_2 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Delay32_out1_re_2 <= Delay32_out1_re_1;
          Delay32_out1_im_2 <= Delay32_out1_im_1;
        end
      end
    end

  assign Data_Type_Conversion_out1_re = {{4{Delay32_out1_re_2[31]}}, Delay32_out1_re_2[31:5]};
  assign Data_Type_Conversion_out1_im = {{4{Delay32_out1_im_2[31]}}, Delay32_out1_im_2[31:5]};

  assign corrOut_re = Data_Type_Conversion_out1_re;

  assign corrOut_im = Data_Type_Conversion_out1_im;

endmodule  // Correlator_block1

