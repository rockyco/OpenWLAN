// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/wlanhdlTimeAndFrequencySynchronization/Correlator_block2.v
// Created: 2026-02-04 22:38:44
// 
// Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Correlator_block2
// Source Path: wlanhdlTimeAndFrequencySynchronization/WLANTimeAndFrequencySynchronization/Fine Time Sync/Correlator
// Hierarchy Level: 2
// Model version: 9.2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Correlator_block2
          (clk,
           reset,
           enb_1_8_1,
           enb_1_8_0,
           enb,
           enb_1_1_1,
           dataIn_re,
           dataIn_im,
           validIn,
           startIn,
           rstIn,
           corrOut,
           corrValid,
           startOut,
           dataOut_re,
           dataOut_im,
           validOut);


  input   clk;
  input   reset;
  input   enb_1_8_1;
  input   enb_1_8_0;
  input   enb;
  input   enb_1_1_1;
  input   signed [15:0] dataIn_re;  // sfix16_En12
  input   signed [15:0] dataIn_im;  // sfix16_En12
  input   validIn;
  input   startIn;
  input   rstIn;
  output  signed [31:0] corrOut;  // sfix32_En15
  output  corrValid;
  output  startOut;
  output  signed [15:0] dataOut_re;  // sfix16_En12
  output  signed [15:0] dataOut_im;  // sfix16_En12
  output  validOut;


  wire signed [36:0] Delay22_out1_re;  // sfix37_En26
  wire signed [36:0] Delay22_out1_im;  // sfix37_En26
  wire Delay23_out1;
  wire signed [31:0] MagnitudeSquared_dataOut;  // sfix32_En15
  wire MagnitudeSquared_validOut;
  reg signed [31:0] MagnitudeSquared_dataOut_1;  // sfix32_En15
  reg signed [31:0] Delay3_bypass_reg;  // sfix32
  wire signed [31:0] Delay3_out1;  // sfix32_En15
  wire MagnitudeSquared_validOut_1;
  reg  MagnitudeSquared_validOut_2;
  reg  Delay4_out1;
  reg  [3:0] Delay24_reg;  // ufix1 [4]
  wire Delay24_out1;
  wire Delay24_out1_1;
  reg  Delay24_out1_2;
  reg  [3:0] Delay5_reg;  // ufix1 [4]
  wire Delay5_out1;
  reg signed [15:0] Delay25_reg_re [0:4];  // sfix16_En12 [5]
  reg signed [15:0] Delay25_reg_im [0:4];  // sfix16_En12 [5]
  reg signed [15:0] Delay25_reg_next_re [0:4];  // sfix16_En12 [5]
  reg signed [15:0] Delay25_reg_next_im [0:4];  // sfix16_En12 [5]
  reg signed [15:0] Delay25_out1_re;  // sfix16_En12
  reg signed [15:0] Delay25_out1_im;  // sfix16_En12
  wire signed [15:0] Delay25_out1_re_1;  // sfix16_En12
  wire signed [15:0] Delay25_out1_im_1;  // sfix16_En12
  reg signed [15:0] Delay25_out1_re_2;  // sfix16_En12
  reg signed [15:0] Delay25_out1_im_2;  // sfix16_En12
  reg signed [15:0] Delay6_reg_re [0:3];  // sfix16_En12 [4]
  reg signed [15:0] Delay6_reg_im [0:3];  // sfix16_En12 [4]
  reg signed [15:0] Delay6_reg_next_re [0:3];  // sfix16_En12 [4]
  reg signed [15:0] Delay6_reg_next_im [0:3];  // sfix16_En12 [4]
  reg signed [15:0] Delay6_out1_re;  // sfix16_En12
  reg signed [15:0] Delay6_out1_im;  // sfix16_En12
  wire validIn_1;
  reg  validIn_2;
  reg  [8:0] Delay7_reg;  // ufix1 [9]
  wire Delay7_out1;
  reg signed [31:0] Delay25_t_0_0;  // int32
  reg signed [31:0] Delay25_t_0_1;  // int32
  reg signed [31:0] Delay25_t_1;  // int32
  reg signed [31:0] Delay6_t_0_0;  // int32
  reg signed [31:0] Delay6_t_0_1;  // int32
  reg signed [31:0] Delay6_t_1;  // int32


  corrFilter u_corrFilter (.clk(clk),
                           .reset(reset),
                           .enb_1_8_1(enb_1_8_1),
                           .enb_1_8_0(enb_1_8_0),
                           .enb(enb),
                           .enb_1_1_1(enb_1_1_1),
                           .dataIn_re(dataIn_re),  // sfix16_En12
                           .dataIn_im(dataIn_im),  // sfix16_En12
                           .validIn(validIn),
                           .rst(rstIn),
                           .dataOut_re(Delay22_out1_re),  // sfix37_En26
                           .dataOut_im(Delay22_out1_im),  // sfix37_En26
                           .validOut(Delay23_out1)
                           );

  MagnitudeSquared_block2 u_MagnitudeSquared (.clk(clk),
                                              .reset(reset),
                                              .enb_1_8_1(enb_1_8_1),
                                              .enb_1_8_0(enb_1_8_0),
                                              .enb(enb),
                                              .dataIn_re(Delay22_out1_re),  // sfix37_En26
                                              .dataIn_im(Delay22_out1_im),  // sfix37_En26
                                              .validIn(Delay23_out1),
                                              .dataOut(MagnitudeSquared_dataOut),  // sfix32_En15
                                              .validOut(MagnitudeSquared_validOut)
                                              );

  always @(posedge clk or posedge reset)
    begin : crp_out_delay_process
      if (reset == 1'b1) begin
        MagnitudeSquared_dataOut_1 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          MagnitudeSquared_dataOut_1 <= MagnitudeSquared_dataOut;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay3_bypass_process
      if (reset == 1'b1) begin
        Delay3_bypass_reg <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Delay3_bypass_reg <= MagnitudeSquared_dataOut_1;
        end
      end
    end

  assign Delay3_out1 = (enb_1_8_1 == 1'b1 ? MagnitudeSquared_dataOut_1 :
              Delay3_bypass_reg);

  assign corrOut = Delay3_out1;

  assign MagnitudeSquared_validOut_1 = MagnitudeSquared_validOut;

  always @(posedge clk or posedge reset)
    begin : Delay41_output_process
      if (reset == 1'b1) begin
        MagnitudeSquared_validOut_2 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          MagnitudeSquared_validOut_2 <= MagnitudeSquared_validOut_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 1'b0;
      end
      else begin
        if (enb_1_8_0) begin
          Delay4_out1 <= MagnitudeSquared_validOut_2;
        end
      end
    end

  assign corrValid = Delay4_out1;

  always @(posedge clk or posedge reset)
    begin : Delay24_process
      if (reset == 1'b1) begin
        Delay24_reg <= {4{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay24_reg[0] <= startIn;
          Delay24_reg[32'sd3:32'sd1] <= Delay24_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay24_out1 = Delay24_reg[3];

  assign Delay24_out1_1 = Delay24_out1;

  always @(posedge clk or posedge reset)
    begin : Delay131_output_process
      if (reset == 1'b1) begin
        Delay24_out1_2 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay24_out1_2 <= Delay24_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay5_process
      if (reset == 1'b1) begin
        Delay5_reg <= {4{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay5_reg[0] <= Delay24_out1_2;
          Delay5_reg[32'sd3:32'sd1] <= Delay5_reg[32'sd2:32'sd0];
        end
      end
    end

  assign Delay5_out1 = Delay5_reg[3];

  assign startOut = Delay5_out1;

  always @(posedge clk or posedge reset)
    begin : Delay25_process
      if (reset == 1'b1) begin
        for(Delay25_t_1 = 32'sd0; Delay25_t_1 <= 32'sd4; Delay25_t_1 = Delay25_t_1 + 32'sd1) begin
          Delay25_reg_re[Delay25_t_1] <= 16'sb0000000000000000;
          Delay25_reg_im[Delay25_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb_1_8_0) begin
          for(Delay25_t_0_1 = 32'sd0; Delay25_t_0_1 <= 32'sd4; Delay25_t_0_1 = Delay25_t_0_1 + 32'sd1) begin
            Delay25_reg_re[Delay25_t_0_1] <= Delay25_reg_next_re[Delay25_t_0_1];
            Delay25_reg_im[Delay25_t_0_1] <= Delay25_reg_next_im[Delay25_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay25_out1_re = Delay25_reg_re[4];
    Delay25_out1_im = Delay25_reg_im[4];
    Delay25_reg_next_re[0] = dataIn_re;
    Delay25_reg_next_im[0] = dataIn_im;

    for(Delay25_t_0_0 = 32'sd0; Delay25_t_0_0 <= 32'sd3; Delay25_t_0_0 = Delay25_t_0_0 + 32'sd1) begin
      Delay25_reg_next_re[Delay25_t_0_0 + 32'sd1] = Delay25_reg_re[Delay25_t_0_0];
      Delay25_reg_next_im[Delay25_t_0_0 + 32'sd1] = Delay25_reg_im[Delay25_t_0_0];
    end

  end

  assign Delay25_out1_re_1 = Delay25_out1_re;

  assign Delay25_out1_im_1 = Delay25_out1_im;

  always @(posedge clk or posedge reset)
    begin : Delay151_output_process
      if (reset == 1'b1) begin
        Delay25_out1_re_2 <= 16'sb0000000000000000;
        Delay25_out1_im_2 <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Delay25_out1_re_2 <= Delay25_out1_re_1;
          Delay25_out1_im_2 <= Delay25_out1_im_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        for(Delay6_t_1 = 32'sd0; Delay6_t_1 <= 32'sd3; Delay6_t_1 = Delay6_t_1 + 32'sd1) begin
          Delay6_reg_re[Delay6_t_1] <= 16'sb0000000000000000;
          Delay6_reg_im[Delay6_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb_1_8_0) begin
          for(Delay6_t_0_1 = 32'sd0; Delay6_t_0_1 <= 32'sd3; Delay6_t_0_1 = Delay6_t_0_1 + 32'sd1) begin
            Delay6_reg_re[Delay6_t_0_1] <= Delay6_reg_next_re[Delay6_t_0_1];
            Delay6_reg_im[Delay6_t_0_1] <= Delay6_reg_next_im[Delay6_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay6_out1_re = Delay6_reg_re[3];
    Delay6_out1_im = Delay6_reg_im[3];
    Delay6_reg_next_re[0] = Delay25_out1_re_2;
    Delay6_reg_next_im[0] = Delay25_out1_im_2;

    for(Delay6_t_0_0 = 32'sd0; Delay6_t_0_0 <= 32'sd2; Delay6_t_0_0 = Delay6_t_0_0 + 32'sd1) begin
      Delay6_reg_next_re[Delay6_t_0_0 + 32'sd1] = Delay6_reg_re[Delay6_t_0_0];
      Delay6_reg_next_im[Delay6_t_0_0 + 32'sd1] = Delay6_reg_im[Delay6_t_0_0];
    end

  end

  assign dataOut_re = Delay6_out1_re;

  assign dataOut_im = Delay6_out1_im;

  assign validIn_1 = validIn;

  always @(posedge clk or posedge reset)
    begin : Delay21_output_process
      if (reset == 1'b1) begin
        validIn_2 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          validIn_2 <= validIn_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        Delay7_reg <= {9{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay7_reg[0] <= validIn_2;
          Delay7_reg[32'sd8:32'sd1] <= Delay7_reg[32'sd7:32'sd0];
        end
      end
    end

  assign Delay7_out1 = Delay7_reg[8];

  assign validOut = Delay7_out1;

endmodule  // Correlator_block2

