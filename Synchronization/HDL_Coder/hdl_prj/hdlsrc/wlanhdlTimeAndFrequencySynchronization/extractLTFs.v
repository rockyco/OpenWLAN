// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/wlanhdlTimeAndFrequencySynchronization/extractLTFs.v
// Created: 2026-02-04 22:38:44
// 
// Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: extractLTFs
// Source Path: wlanhdlTimeAndFrequencySynchronization/WLANTimeAndFrequencySynchronization/Fine Time Sync/Peak Searcher/maxPeakSearcher/extractLTFs
// Hierarchy Level: 4
// Model version: 9.2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module extractLTFs
          (clk,
           reset,
           enb_1_8_1,
           enb,
           enb_1,
           rst,
           valid,
           count);


  input   clk;
  input   reset;
  input   enb_1_8_1;
  input   enb;
  input   enb_1;
  input   rst;
  output  valid;
  output  [15:0] count;  // uint16


  reg  [2:0] rd_12_reg;  // ufix1 [3]
  wire rst_1;
  wire enb_2;
  reg  [2:0] rd_2_reg;  // ufix1 [3]
  wire enb_3;
  wire [15:0] count_step;  // uint16
  wire [15:0] count_from;  // uint16
  wire [15:0] count_reset;  // uint16
  reg [15:0] HDL_Counter_out1;  // uint16
  wire [15:0] count_1;  // uint16
  reg [15:0] count_2;  // uint16
  wire need_to_wrap;
  reg  need_to_wrap_1;
  wire [15:0] count_value;  // uint16
  reg [15:0] count_value_1;  // uint16
  wire [15:0] HDL_Counter_out1_1;  // uint16
  wire [15:0] HDL_Counter_out1_2;  // uint16
  reg [15:0] rd_3_reg [0:1];  // ufix16 [2]
  wire [15:0] rd_3_reg_next [0:1];  // ufix16 [2]
  wire [15:0] HDL_Counter_out1_3;  // uint16
  wire [15:0] count_3;  // uint16
  reg [15:0] count_4;  // uint16
  wire [15:0] count_5;  // uint16
  reg [15:0] count_6;  // uint16
  reg [15:0] HDL_Counter_bypass_reg;  // ufix16
  wire [15:0] HDL_Counter_out1_4;  // uint16
  reg [15:0] HDL_Counter_out1_5;  // uint16
  wire Compare_To_Constant_out1;
  wire enb_4;
  reg  enb_5;
  wire Logical_Operator_out1;
  reg  Logical_Operator_out1_1;
  reg  Logical_Operator_out1_2;
  wire [15:0] count_step_1;  // uint16
  wire [15:0] count_from_1;  // uint16
  wire [15:0] count_reset_1;  // uint16
  reg [15:0] HDL_Counter1_out1;  // uint16
  wire [15:0] count_7;  // uint16
  reg [15:0] count_8;  // uint16
  wire need_to_wrap_2;
  reg  need_to_wrap_3;
  wire [15:0] count_value_2;  // uint16
  reg [15:0] count_value_3;  // uint16
  reg [15:0] rd_71_reg [0:1];  // ufix16 [2]
  wire [15:0] rd_71_reg_next [0:1];  // ufix16 [2]
  wire [15:0] HDL_Counter1_out1_1;  // uint16
  wire [15:0] count_9;  // uint16
  reg [15:0] count_10;  // uint16
  wire [15:0] count_11;  // uint16
  reg [15:0] count_12;  // uint16
  reg [15:0] HDL_Counter1_bypass_reg;  // ufix16
  wire [15:0] HDL_Counter1_out1_2;  // uint16
  wire [15:0] HDL_Counter1_out1_3;  // uint16
  wire Compare_To_Constant1_out1;
  reg  Compare_To_Constant1_out1_1;
  wire Logical_Operator1_out1;
  reg signed [31:0] rd_3_t_0_0;  // int32
  reg signed [31:0] rd_3_t_1;  // int32
  reg signed [31:0] rd_71_t_0_0;  // int32
  reg signed [31:0] rd_71_t_1;  // int32


  always @(posedge clk or posedge reset)
    begin : rd_12_process
      if (reset == 1'b1) begin
        rd_12_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          rd_12_reg[0] <= rst;
          rd_12_reg[32'sd2:32'sd1] <= rd_12_reg[32'sd1:32'sd0];
        end
      end
    end

  assign rst_1 = rd_12_reg[2];

  assign enb_2 = enb_1;

  always @(posedge clk or posedge reset)
    begin : rd_2_process
      if (reset == 1'b1) begin
        rd_2_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          rd_2_reg[0] <= enb_2;
          rd_2_reg[32'sd2:32'sd1] <= rd_2_reg[32'sd1:32'sd0];
        end
      end
    end

  assign enb_3 = rd_2_reg[2];

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 65535
  assign count_step = 16'b0000000000000001;

  assign count_from = 16'b0000000000000000;

  assign count_reset = 16'b0000000000000000;

  assign count_1 = HDL_Counter_out1 + count_step;

  always @(posedge clk or posedge reset)
    begin : rd_5_process
      if (reset == 1'b1) begin
        count_2 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_2 <= count_1;
        end
      end
    end

  assign need_to_wrap = HDL_Counter_out1 == 16'b1111111111111111;

  always @(posedge clk or posedge reset)
    begin : rd_4_process
      if (reset == 1'b1) begin
        need_to_wrap_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          need_to_wrap_1 <= need_to_wrap;
        end
      end
    end

  assign count_value = (need_to_wrap_1 == 1'b0 ? count_2 :
              count_from);

  always @(posedge clk or posedge reset)
    begin : rd_6_process
      if (reset == 1'b1) begin
        count_value_1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_value_1 <= count_value;
        end
      end
    end

  assign HDL_Counter_out1_2 = HDL_Counter_out1_1;

  always @(posedge clk or posedge reset)
    begin : rd_0_process
      if (reset == 1'b1) begin
        HDL_Counter_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          HDL_Counter_out1 <= HDL_Counter_out1_2;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rd_3_process
      if (reset == 1'b1) begin
        for(rd_3_t_1 = 32'sd0; rd_3_t_1 <= 32'sd1; rd_3_t_1 = rd_3_t_1 + 32'sd1) begin
          rd_3_reg[rd_3_t_1] <= 16'b0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_3_t_0_0 = 32'sd0; rd_3_t_0_0 <= 32'sd1; rd_3_t_0_0 = rd_3_t_0_0 + 32'sd1) begin
            rd_3_reg[rd_3_t_0_0] <= rd_3_reg_next[rd_3_t_0_0];
          end
        end
      end
    end

  assign HDL_Counter_out1_3 = rd_3_reg[1];
  assign rd_3_reg_next[0] = HDL_Counter_out1;
  assign rd_3_reg_next[1] = rd_3_reg[0];

  assign count_3 = (enb_3 == 1'b0 ? HDL_Counter_out1_3 :
              count_value_1);

  always @(posedge clk or posedge reset)
    begin : rd_7_process
      if (reset == 1'b1) begin
        count_4 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_4 <= count_3;
        end
      end
    end

  assign count_5 = (rst_1 == 1'b0 ? count_4 :
              count_reset);

  always @(posedge clk or posedge reset)
    begin : crp_out_delay_process
      if (reset == 1'b1) begin
        count_6 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_6 <= count_5;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : HDL_Counter_bypass_process
      if (reset == 1'b1) begin
        HDL_Counter_bypass_reg <= 16'b0000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          HDL_Counter_bypass_reg <= count_6;
        end
      end
    end

  assign HDL_Counter_out1_1 = (enb_1_8_1 == 1'b1 ? count_6 :
              HDL_Counter_bypass_reg);

  assign HDL_Counter_out1_4 = HDL_Counter_out1_1;

  always @(posedge clk or posedge reset)
    begin : rd_21_process
      if (reset == 1'b1) begin
        HDL_Counter_out1_5 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          HDL_Counter_out1_5 <= HDL_Counter_out1_4;
        end
      end
    end

  assign Compare_To_Constant_out1 = HDL_Counter_out1_5 >= 16'b0000000010011111;

  assign enb_4 = enb_1;

  always @(posedge clk or posedge reset)
    begin : rd_31_process
      if (reset == 1'b1) begin
        enb_5 <= 1'b0;
      end
      else begin
        if (enb) begin
          enb_5 <= enb_4;
        end
      end
    end

  assign Logical_Operator_out1 = Compare_To_Constant_out1 & enb_5;

  always @(posedge clk or posedge reset)
    begin : rd_41_process
      if (reset == 1'b1) begin
        Logical_Operator_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Logical_Operator_out1_1 <= Logical_Operator_out1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rd_61_process
      if (reset == 1'b1) begin
        Logical_Operator_out1_2 <= 1'b0;
      end
      else begin
        if (enb) begin
          Logical_Operator_out1_2 <= Logical_Operator_out1_1;
        end
      end
    end

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 65535
  assign count_step_1 = 16'b0000000000000001;

  assign count_from_1 = 16'b0000000000000000;

  assign count_reset_1 = 16'b0000000000000000;

  assign count_7 = HDL_Counter1_out1 + count_step_1;

  always @(posedge clk or posedge reset)
    begin : rd_9_process
      if (reset == 1'b1) begin
        count_8 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_8 <= count_7;
        end
      end
    end

  assign need_to_wrap_2 = HDL_Counter1_out1 == 16'b1111111111111111;

  always @(posedge clk or posedge reset)
    begin : rd_8_process
      if (reset == 1'b1) begin
        need_to_wrap_3 <= 1'b0;
      end
      else begin
        if (enb) begin
          need_to_wrap_3 <= need_to_wrap_2;
        end
      end
    end

  assign count_value_2 = (need_to_wrap_3 == 1'b0 ? count_8 :
              count_from_1);

  always @(posedge clk or posedge reset)
    begin : rd_10_process
      if (reset == 1'b1) begin
        count_value_3 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_value_3 <= count_value_2;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rd_71_process
      if (reset == 1'b1) begin
        for(rd_71_t_1 = 32'sd0; rd_71_t_1 <= 32'sd1; rd_71_t_1 = rd_71_t_1 + 32'sd1) begin
          rd_71_reg[rd_71_t_1] <= 16'b0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_71_t_0_0 = 32'sd0; rd_71_t_0_0 <= 32'sd1; rd_71_t_0_0 = rd_71_t_0_0 + 32'sd1) begin
            rd_71_reg[rd_71_t_0_0] <= rd_71_reg_next[rd_71_t_0_0];
          end
        end
      end
    end

  assign HDL_Counter1_out1_1 = rd_71_reg[1];
  assign rd_71_reg_next[0] = HDL_Counter1_out1;
  assign rd_71_reg_next[1] = rd_71_reg[0];

  assign count_9 = (Logical_Operator_out1_2 == 1'b0 ? HDL_Counter1_out1_1 :
              count_value_3);

  always @(posedge clk or posedge reset)
    begin : rd_11_process
      if (reset == 1'b1) begin
        count_10 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_10 <= count_9;
        end
      end
    end

  assign count_11 = (rst_1 == 1'b0 ? count_10 :
              count_reset_1);

  always @(posedge clk or posedge reset)
    begin : crp_out_delay1_process
      if (reset == 1'b1) begin
        count_12 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_12 <= count_11;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : HDL_Counter1_bypass_process
      if (reset == 1'b1) begin
        HDL_Counter1_bypass_reg <= 16'b0000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          HDL_Counter1_bypass_reg <= count_12;
        end
      end
    end

  assign HDL_Counter1_out1_2 = (enb_1_8_1 == 1'b1 ? count_12 :
              HDL_Counter1_bypass_reg);

  assign HDL_Counter1_out1_3 = HDL_Counter1_out1_2;

  always @(posedge clk or posedge reset)
    begin : rd_01_process
      if (reset == 1'b1) begin
        HDL_Counter1_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          HDL_Counter1_out1 <= HDL_Counter1_out1_3;
        end
      end
    end

  assign Compare_To_Constant1_out1 = HDL_Counter1_out1 < 16'b0000000010000001;

  always @(posedge clk or posedge reset)
    begin : rd_1_process
      if (reset == 1'b1) begin
        Compare_To_Constant1_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Compare_To_Constant1_out1_1 <= Compare_To_Constant1_out1;
        end
      end
    end

  assign Logical_Operator1_out1 = Compare_To_Constant1_out1_1 & Logical_Operator_out1_1;

  assign valid = Logical_Operator1_out1;

  assign count = HDL_Counter1_out1;

endmodule  // extractLTFs

