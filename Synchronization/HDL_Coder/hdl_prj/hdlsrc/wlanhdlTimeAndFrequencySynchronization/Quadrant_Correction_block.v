// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/wlanhdlTimeAndFrequencySynchronization/Quadrant_Correction_block.v
// Created: 2026-02-04 22:38:44
// 
// Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Quadrant_Correction_block
// Source Path: wlanhdlTimeAndFrequencySynchronization/WLANTimeAndFrequencySynchronization/Fine CFO Estimation and 
// Correction/Fine CFO Estimation/HDL_CMA_core/Quadrant_Correctio
// Hierarchy Level: 3
// Model version: 9.2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Quadrant_Correction_block
          (clk,
           reset,
           enb,
           zin,
           QA_Control,
           zout);


  input   clk;
  input   reset;
  input   enb;
  input   signed [33:0] zin;  // sfix34_En33
  input   [4:0] QA_Control;  // ufix5
  output  signed [33:0] zout;  // sfix34_En33


  reg [4:0] QA_Control_1;  // ufix5
  wire yZeroXPositive;  // ufix1
  reg  [1:0] rd_1_reg;  // ufix1 [2]
  wire yZeroXPositive_1;  // ufix1
  wire yZeroXNegative;  // ufix1
  wire [1:0] xyNegative;  // ufix2
  reg [1:0] rd_5_reg [0:1];  // ufix2 [2]
  wire [1:0] rd_5_reg_next [0:1];  // ufix2 [2]
  wire [1:0] xyNegative_1;  // ufix2
  wire AbsRel;  // ufix1
  wire signed [33:0] pidivtwo;  // sfix34_En33
  reg signed [33:0] zin_1;  // sfix34_En33
  wire signed [33:0] pivdivtwosubout;  // sfix34_En33
  wire signed [33:0] mux1out;  // sfix34_En33
  reg signed [33:0] mux1out_1;  // sfix34_En33
  reg signed [33:0] mux1out_2;  // sfix34_En33
  wire signed [34:0] Negation_cast;  // sfix35_En33
  wire signed [34:0] Negation_cast_1;  // sfix35_En33
  wire signed [35:0] Negation_cast_2;  // sfix36_En33
  wire signed [33:0] mux1out_negate;  // sfix34_En33
  reg signed [33:0] mux1out_negate_1;  // sfix34_En33
  wire signed [33:0] pionepos;  // sfix34_En33
  wire signed [33:0] pi_subtraction;  // sfix34_En33
  reg signed [33:0] rd_8_reg [0:1];  // sfix34 [2]
  wire signed [33:0] rd_8_reg_next [0:1];  // sfix34_En33 [2]
  wire signed [33:0] pi_subtraction_1;  // sfix34_En33
  wire signed [33:0] pioneneg;  // sfix34_En33
  wire signed [33:0] negpi_addition;  // sfix34_En33
  reg  [1:0] rd_4_reg;  // ufix1 [2]
  wire yZeroXNegative_1;  // ufix1
  reg signed [33:0] rd_9_reg [0:1];  // sfix34 [2]
  wire signed [33:0] rd_9_reg_next [0:1];  // sfix34_En33 [2]
  wire signed [33:0] negpi_addition_1;  // sfix34_En33
  wire signed [33:0] mux2out;  // sfix34_En33
  wire signed [33:0] mux5out;  // sfix34_En33
  wire signed [33:0] zero;  // sfix34_En33
  wire signed [33:0] mux6out;  // sfix34_En33
  reg signed [31:0] rd_5_t_0_0;  // int32
  reg signed [31:0] rd_5_t_1;  // int32
  reg signed [31:0] rd_8_t_0_0;  // int32
  reg signed [31:0] rd_8_t_1;  // int32
  reg signed [31:0] rd_9_t_0_0;  // int32
  reg signed [31:0] rd_9_t_1;  // int32


  always @(posedge clk or posedge reset)
    begin : rd_0_process
      if (reset == 1'b1) begin
        QA_Control_1 <= 5'b00000;
      end
      else begin
        if (enb) begin
          QA_Control_1 <= QA_Control;
        end
      end
    end

  assign yZeroXPositive = QA_Control_1[4];

  always @(posedge clk or posedge reset)
    begin : rd_1_process
      if (reset == 1'b1) begin
        rd_1_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          rd_1_reg[0] <= yZeroXPositive;
          rd_1_reg[1] <= rd_1_reg[0];
        end
      end
    end

  assign yZeroXPositive_1 = rd_1_reg[1];

  assign yZeroXNegative = QA_Control_1[3];

  assign xyNegative = QA_Control_1[1:0];

  always @(posedge clk or posedge reset)
    begin : rd_5_process
      if (reset == 1'b1) begin
        for(rd_5_t_1 = 32'sd0; rd_5_t_1 <= 32'sd1; rd_5_t_1 = rd_5_t_1 + 32'sd1) begin
          rd_5_reg[rd_5_t_1] <= 2'b00;
        end
      end
      else begin
        if (enb) begin
          for(rd_5_t_0_0 = 32'sd0; rd_5_t_0_0 <= 32'sd1; rd_5_t_0_0 = rd_5_t_0_0 + 32'sd1) begin
            rd_5_reg[rd_5_t_0_0] <= rd_5_reg_next[rd_5_t_0_0];
          end
        end
      end
    end

  assign xyNegative_1 = rd_5_reg[1];
  assign rd_5_reg_next[0] = xyNegative;
  assign rd_5_reg_next[1] = rd_5_reg[0];

  assign AbsRel = QA_Control_1[2];

  assign pidivtwo = 34'sh100000000;

  always @(posedge clk or posedge reset)
    begin : rd_2_process
      if (reset == 1'b1) begin
        zin_1 <= 34'sh000000000;
      end
      else begin
        if (enb) begin
          zin_1 <= zin;
        end
      end
    end

  assign pivdivtwosubout = pidivtwo - zin_1;

  assign mux1out = (AbsRel == 1'b0 ? pivdivtwosubout :
              zin_1);

  always @(posedge clk or posedge reset)
    begin : rd_3_process
      if (reset == 1'b1) begin
        mux1out_1 <= 34'sh000000000;
      end
      else begin
        if (enb) begin
          mux1out_1 <= mux1out;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rd_6_process
      if (reset == 1'b1) begin
        mux1out_2 <= 34'sh000000000;
      end
      else begin
        if (enb) begin
          mux1out_2 <= mux1out_1;
        end
      end
    end

  assign Negation_cast = {mux1out_1[33], mux1out_1};
  assign Negation_cast_1 =  - (Negation_cast);
  assign Negation_cast_2 = {Negation_cast_1[34], Negation_cast_1};
  assign mux1out_negate = Negation_cast_2[33:0];

  always @(posedge clk or posedge reset)
    begin : rd_7_process
      if (reset == 1'b1) begin
        mux1out_negate_1 <= 34'sh000000000;
      end
      else begin
        if (enb) begin
          mux1out_negate_1 <= mux1out_negate;
        end
      end
    end

  assign pionepos = 34'sh1FFFFFFFF;

  assign pi_subtraction = pionepos - mux1out;

  always @(posedge clk or posedge reset)
    begin : rd_8_process
      if (reset == 1'b1) begin
        for(rd_8_t_1 = 32'sd0; rd_8_t_1 <= 32'sd1; rd_8_t_1 = rd_8_t_1 + 32'sd1) begin
          rd_8_reg[rd_8_t_1] <= 34'sh000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_8_t_0_0 = 32'sd0; rd_8_t_0_0 <= 32'sd1; rd_8_t_0_0 = rd_8_t_0_0 + 32'sd1) begin
            rd_8_reg[rd_8_t_0_0] <= rd_8_reg_next[rd_8_t_0_0];
          end
        end
      end
    end

  assign pi_subtraction_1 = rd_8_reg[1];
  assign rd_8_reg_next[0] = pi_subtraction;
  assign rd_8_reg_next[1] = rd_8_reg[0];

  assign pioneneg = 34'sh200000000;

  assign negpi_addition = pioneneg + mux1out;

  always @(posedge clk or posedge reset)
    begin : rd_4_process
      if (reset == 1'b1) begin
        rd_4_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          rd_4_reg[0] <= yZeroXNegative;
          rd_4_reg[1] <= rd_4_reg[0];
        end
      end
    end

  assign yZeroXNegative_1 = rd_4_reg[1];

  always @(posedge clk or posedge reset)
    begin : rd_9_process
      if (reset == 1'b1) begin
        for(rd_9_t_1 = 32'sd0; rd_9_t_1 <= 32'sd1; rd_9_t_1 = rd_9_t_1 + 32'sd1) begin
          rd_9_reg[rd_9_t_1] <= 34'sh000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_9_t_0_0 = 32'sd0; rd_9_t_0_0 <= 32'sd1; rd_9_t_0_0 = rd_9_t_0_0 + 32'sd1) begin
            rd_9_reg[rd_9_t_0_0] <= rd_9_reg_next[rd_9_t_0_0];
          end
        end
      end
    end

  assign negpi_addition_1 = rd_9_reg[1];
  assign rd_9_reg_next[0] = negpi_addition;
  assign rd_9_reg_next[1] = rd_9_reg[0];

  assign mux2out = (xyNegative_1 == 2'b00 ? mux1out_2 :
              (xyNegative_1 == 2'b01 ? mux1out_negate_1 :
              (xyNegative_1 == 2'b10 ? pi_subtraction_1 :
              negpi_addition_1)));

  assign mux5out = (yZeroXNegative_1 == 1'b0 ? mux2out :
              pionepos);

  assign zero = 34'sh000000000;

  assign mux6out = (yZeroXPositive_1 == 1'b0 ? mux5out :
              zero);

  assign zout = mux6out;

endmodule  // Quadrant_Correction_block

