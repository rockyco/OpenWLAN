// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/wlanhdlTimeAndFrequencySynchronization/considerFirstPeak.v
// Created: 2026-02-04 22:38:43
// 
// Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: considerFirstPeak
// Source Path: wlanhdlTimeAndFrequencySynchronization/WLANTimeAndFrequencySynchronization/Coarse Time Sync/Peak 
// Detector/considerFirstPea
// Hierarchy Level: 3
// Model version: 9.2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module considerFirstPeak
          (clk,
           reset,
           enb_1_8_1,
           enb,
           peakIn,
           peakOut,
           validOut);


  input   clk;
  input   reset;
  input   enb_1_8_1;
  input   enb;
  input   peakIn;
  output  peakOut;
  output  validOut;


  wire peakIn_1;
  reg  [2:0] rd_3_reg;  // ufix1 [3]
  wire peakIn_2;
  wire [15:0] count_step;  // uint16
  wire [15:0] count_from;  // uint16
  wire [15:0] count_reset;  // uint16
  reg [15:0] HDL_Counter1_out1;  // uint16
  wire [15:0] count;  // uint16
  reg [15:0] count_1;  // uint16
  wire need_to_wrap;
  reg  need_to_wrap_1;
  wire [15:0] count_value;  // uint16
  reg [15:0] count_value_1;  // uint16
  reg [15:0] rd_4_reg [0:1];  // ufix16 [2]
  wire [15:0] rd_4_reg_next [0:1];  // ufix16 [2]
  wire [15:0] HDL_Counter1_out1_1;  // uint16
  wire [15:0] count_2;  // uint16
  reg [15:0] count_3;  // uint16
  wire [15:0] HDL_Counter1_out1_2;  // uint16
  wire Compare_To_Constant_out1;
  reg  [2:0] rd_2_reg;  // ufix1 [3]
  wire Compare_To_Constant_out1_1;
  wire [15:0] count_4;  // uint16
  reg [15:0] count_5;  // uint16
  reg [15:0] HDL_Counter1_bypass_reg;  // ufix16
  wire [15:0] HDL_Counter1_out1_3;  // uint16
  wire Compare_To_Constant1_out1;
  wire Logical_Operator1_out1;
  reg  Logical_Operator1_out1_1;
  reg  Logical_Operator6_out1;
  reg  Delay9_bypass_reg;  // ufix1
  wire Delay9_out1;
  wire Delay9_out1_1;
  reg  Delay9_out1_2;
  wire Logical_Operator6_out1_1;
  reg  Delay10_bypass_reg;  // ufix1
  wire Delay10_out1;
  wire Delay10_out1_1;
  reg  Delay10_out1_2;
  wire Logical_Operator7_out1;
  reg  Logical_Operator7_out1_1;
  reg  Delay11_bypass_reg;  // ufix1
  wire Delay11_out1;
  wire Delay11_out1_1;
  reg  Delay11_out1_2;
  wire Switch_out1;
  wire Logical_Operator2_out1;
  reg  Logical_Operator2_out1_1;
  reg  Delay7_bypass_reg;  // ufix1
  wire Delay7_out1;
  wire Delay7_out1_1;
  reg signed [31:0] rd_4_t_0_0;  // int32
  reg signed [31:0] rd_4_t_1;  // int32


  assign peakIn_1 = peakIn;

  always @(posedge clk or posedge reset)
    begin : rd_3_process
      if (reset == 1'b1) begin
        rd_3_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          rd_3_reg[0] <= peakIn_1;
          rd_3_reg[32'sd2:32'sd1] <= rd_3_reg[32'sd1:32'sd0];
        end
      end
    end

  assign peakIn_2 = rd_3_reg[2];

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 159
  assign count_step = 16'b0000000000000001;

  assign count_from = 16'b0000000000000000;

  assign count_reset = 16'b0000000000000000;

  assign count = HDL_Counter1_out1 + count_step;

  always @(posedge clk or posedge reset)
    begin : rd_6_process
      if (reset == 1'b1) begin
        count_1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_1 <= count;
        end
      end
    end

  assign need_to_wrap = HDL_Counter1_out1 == 16'b0000000010011111;

  always @(posedge clk or posedge reset)
    begin : rd_5_process
      if (reset == 1'b1) begin
        need_to_wrap_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          need_to_wrap_1 <= need_to_wrap;
        end
      end
    end

  assign count_value = (need_to_wrap_1 == 1'b0 ? count_1 :
              count_from);

  always @(posedge clk or posedge reset)
    begin : rd_7_process
      if (reset == 1'b1) begin
        count_value_1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_value_1 <= count_value;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rd_4_process
      if (reset == 1'b1) begin
        for(rd_4_t_1 = 32'sd0; rd_4_t_1 <= 32'sd1; rd_4_t_1 = rd_4_t_1 + 32'sd1) begin
          rd_4_reg[rd_4_t_1] <= 16'b0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_4_t_0_0 = 32'sd0; rd_4_t_0_0 <= 32'sd1; rd_4_t_0_0 = rd_4_t_0_0 + 32'sd1) begin
            rd_4_reg[rd_4_t_0_0] <= rd_4_reg_next[rd_4_t_0_0];
          end
        end
      end
    end

  assign HDL_Counter1_out1_1 = rd_4_reg[1];
  assign rd_4_reg_next[0] = HDL_Counter1_out1;
  assign rd_4_reg_next[1] = rd_4_reg[0];

  assign count_2 = (peakIn_2 == 1'b0 ? HDL_Counter1_out1_1 :
              count_value_1);

  always @(posedge clk or posedge reset)
    begin : rd_8_process
      if (reset == 1'b1) begin
        count_3 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_3 <= count_2;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rd_1_process
      if (reset == 1'b1) begin
        HDL_Counter1_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          HDL_Counter1_out1 <= HDL_Counter1_out1_2;
        end
      end
    end

  assign Compare_To_Constant_out1 = HDL_Counter1_out1 == 16'b0000000010011111;

  always @(posedge clk or posedge reset)
    begin : rd_2_process
      if (reset == 1'b1) begin
        rd_2_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          rd_2_reg[0] <= Compare_To_Constant_out1;
          rd_2_reg[32'sd2:32'sd1] <= rd_2_reg[32'sd1:32'sd0];
        end
      end
    end

  assign Compare_To_Constant_out1_1 = rd_2_reg[2];

  assign count_4 = (Compare_To_Constant_out1_1 == 1'b0 ? count_3 :
              count_reset);

  always @(posedge clk or posedge reset)
    begin : crp_out_delay_process
      if (reset == 1'b1) begin
        count_5 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_5 <= count_4;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : HDL_Counter1_bypass_process
      if (reset == 1'b1) begin
        HDL_Counter1_bypass_reg <= 16'b0000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          HDL_Counter1_bypass_reg <= count_5;
        end
      end
    end

  assign HDL_Counter1_out1_3 = (enb_1_8_1 == 1'b1 ? count_5 :
              HDL_Counter1_bypass_reg);

  assign HDL_Counter1_out1_2 = HDL_Counter1_out1_3;

  assign Compare_To_Constant1_out1 = HDL_Counter1_out1_2 == 16'b0000000000000000;

  assign Logical_Operator1_out1 = Compare_To_Constant1_out1 & peakIn_1;

  always @(posedge clk or posedge reset)
    begin : rd_11_process
      if (reset == 1'b1) begin
        Logical_Operator1_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Logical_Operator1_out1_1 <= Logical_Operator1_out1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay9_bypass_process
      if (reset == 1'b1) begin
        Delay9_bypass_reg <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay9_bypass_reg <= Logical_Operator6_out1;
        end
      end
    end

  assign Delay9_out1 = (enb_1_8_1 == 1'b1 ? Logical_Operator6_out1 :
              Delay9_bypass_reg);

  assign Delay9_out1_1 = Delay9_out1;

  always @(posedge clk or posedge reset)
    begin : rd_14_process
      if (reset == 1'b1) begin
        Delay9_out1_2 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay9_out1_2 <= Delay9_out1_1;
        end
      end
    end

  assign Logical_Operator6_out1_1 = Logical_Operator1_out1_1 | Delay9_out1_2;

  always @(posedge clk or posedge reset)
    begin : crp_out_delay3_process
      if (reset == 1'b1) begin
        Logical_Operator6_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Logical_Operator6_out1 <= Logical_Operator6_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay10_bypass_process
      if (reset == 1'b1) begin
        Delay10_bypass_reg <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay10_bypass_reg <= Logical_Operator6_out1;
        end
      end
    end

  assign Delay10_out1 = (enb_1_8_1 == 1'b1 ? Logical_Operator6_out1 :
              Delay10_bypass_reg);

  assign Delay10_out1_1 = Delay10_out1;

  always @(posedge clk or posedge reset)
    begin : rd_10_process
      if (reset == 1'b1) begin
        Delay10_out1_2 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay10_out1_2 <= Delay10_out1_1;
        end
      end
    end

  assign Logical_Operator7_out1 = Delay10_out1_2 & Logical_Operator1_out1_1;

  always @(posedge clk or posedge reset)
    begin : crp_out_delay1_process
      if (reset == 1'b1) begin
        Logical_Operator7_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Logical_Operator7_out1_1 <= Logical_Operator7_out1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay11_bypass_process
      if (reset == 1'b1) begin
        Delay11_bypass_reg <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay11_bypass_reg <= Logical_Operator7_out1_1;
        end
      end
    end

  assign Delay11_out1 = (enb_1_8_1 == 1'b1 ? Logical_Operator7_out1_1 :
              Delay11_bypass_reg);

  assign Delay11_out1_1 = Delay11_out1;

  always @(posedge clk or posedge reset)
    begin : rd_13_process
      if (reset == 1'b1) begin
        Delay11_out1_2 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay11_out1_2 <= Delay11_out1_1;
        end
      end
    end

  assign Switch_out1 = (Delay10_out1_2 == 1'b0 ? Logical_Operator1_out1_1 :
              Delay11_out1_2);

  assign peakOut = Switch_out1;

  always @(posedge clk or posedge reset)
    begin : crp_out_delay2_process
      if (reset == 1'b1) begin
        Logical_Operator2_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Logical_Operator2_out1_1 <= Logical_Operator2_out1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay7_bypass_process
      if (reset == 1'b1) begin
        Delay7_bypass_reg <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay7_bypass_reg <= Logical_Operator2_out1_1;
        end
      end
    end

  assign Delay7_out1 = (enb_1_8_1 == 1'b1 ? Logical_Operator2_out1_1 :
              Delay7_bypass_reg);

  assign Delay7_out1_1 = Delay7_out1;

  assign Logical_Operator2_out1 = Logical_Operator1_out1 | Delay7_out1_1;

  assign validOut = Logical_Operator2_out1;

endmodule  // considerFirstPeak

