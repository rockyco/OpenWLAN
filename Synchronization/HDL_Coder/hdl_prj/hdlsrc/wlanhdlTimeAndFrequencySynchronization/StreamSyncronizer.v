// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/wlanhdlTimeAndFrequencySynchronization/StreamSyncronizer.v
// Created: 2026-02-04 22:38:43
// 
// Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: StreamSyncronizer
// Source Path: wlanhdlTimeAndFrequencySynchronization/WLANTimeAndFrequencySynchronization/Coarse Time Sync/Energy 
// Calculator/streamSynchronizer/StreamSyncronize
// Hierarchy Level: 4
// Model version: 9.2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module StreamSyncronizer
          (clk,
           reset,
           enb_1_8_0,
           pop,
           dataIn,
           push,
           dataOut,
           validOut);


  input   clk;
  input   reset;
  input   enb_1_8_0;
  input   pop;
  input   signed [70:0] dataIn;  // sfix71_En54
  input   push;
  output  signed [70:0] dataOut;  // sfix71_En54
  output  validOut;


  reg signed [70:0] dataOut_1;  // sfix71_En54
  reg  validOut_1;
  reg [7:0] wrAddr;  // ufix8
  reg [7:0] rdAddr;  // ufix8
  reg signed [70:0] dataOutReg;  // sfix71
  reg  validOutReg;
  reg signed [70:0] mem [0:255];  // sfix71 [256]
  reg signed [15:0] level;  // int16
  reg [7:0] wrAddr_next;  // ufix8
  reg [7:0] rdAddr_next;  // ufix8
  reg signed [70:0] dataOutReg_next;  // sfix71_En54
  reg  validOutReg_next;
  reg signed [70:0] mem_next [0:255];  // sfix71_En54 [256]
  reg signed [15:0] level_next;  // int16
  reg signed [15:0] level_temp;  // int16
  reg signed [31:0] t_0;  // int32
  reg signed [16:0] sub_temp;  // sfix17
  reg signed [16:0] add_temp;  // sfix17
  reg signed [16:0] t_1;  // sfix17
  reg signed [16:0] t_2;  // sfix17
  reg signed [31:0] t_0_0;  // int32
  reg signed [31:0] t_1_0;  // int32


  always @(posedge clk or posedge reset)
    begin : StreamSyncronizer_1_process
      if (reset == 1'b1) begin
        wrAddr <= 8'b00000000;
        rdAddr <= 8'b00000000;
        dataOutReg <= 71'sh000000000000000000;
        validOutReg <= 1'b0;

        for(t_1_0 = 32'sd0; t_1_0 <= 32'sd255; t_1_0 = t_1_0 + 32'sd1) begin
          mem[t_1_0] <= 71'sh000000000000000000;
        end

        level <= 16'sd0;
      end
      else begin
        if (enb_1_8_0) begin
          wrAddr <= wrAddr_next;
          rdAddr <= rdAddr_next;
          dataOutReg <= dataOutReg_next;
          validOutReg <= validOutReg_next;

          for(t_0_0 = 32'sd0; t_0_0 <= 32'sd255; t_0_0 = t_0_0 + 32'sd1) begin
            mem[t_0_0] <= mem_next[t_0_0];
          end

          level <= level_next;
        end
      end
    end

  always @* begin
    sub_temp = 17'sb00000000000000000;
    add_temp = 17'sb00000000000000000;
    t_1 = 17'sb00000000000000000;
    t_2 = 17'sb00000000000000000;
    level_temp = level;
    wrAddr_next = wrAddr;
    rdAddr_next = rdAddr;
    dataOutReg_next = dataOutReg;

    for(t_0 = 32'sd0; t_0 <= 32'sd255; t_0 = t_0 + 32'sd1) begin
      mem_next[t_0] = mem[t_0];
    end

    //------------------------------------------------------------------------
    // Constants
    //------------------------------------------------------------------------
    // Persistent variable initialization
    //------------------------------------------------------------------------
    // Outputs
    //------------------------------------------------------------------------
    //------------------------------------------------------------------------
    // Calculate next state values
    //------------------------------------------------------------------------
    if (pop) begin
      dataOutReg_next = mem[rdAddr];
      rdAddr_next = rdAddr + 8'b00000001;
      t_1 = {level[15], level};
      sub_temp = t_1 - 17'sb00000000000000001;
      if ((sub_temp[16] == 1'b0) && (sub_temp[15] != 1'b0)) begin
        level_temp = 16'sb0111111111111111;
      end
      else if ((sub_temp[16] == 1'b1) && (sub_temp[15] != 1'b1)) begin
        level_temp = 16'sb1000000000000000;
      end
      else begin
        level_temp = sub_temp[15:0];
      end
    end
    if (push) begin
      mem_next[wrAddr] = dataIn;
      wrAddr_next = wrAddr + 8'b00000001;
      t_2 = {level_temp[15], level_temp};
      add_temp = t_2 + 17'sb00000000000000001;
      if ((add_temp[16] == 1'b0) && (add_temp[15] != 1'b0)) begin
        level_temp = 16'sb0111111111111111;
      end
      else if ((add_temp[16] == 1'b1) && (add_temp[15] != 1'b1)) begin
        level_temp = 16'sb1000000000000000;
      end
      else begin
        level_temp = add_temp[15:0];
      end
    end
    validOutReg_next = pop;
    dataOut_1 = dataOutReg;
    validOut_1 = validOutReg;
    level_next = level_temp;
  end

  assign dataOut = dataOut_1;

  assign validOut = validOut_1;

endmodule  // StreamSyncronizer

