// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/wlanhdlTimeAndFrequencySynchronization/NCO.v
// Created: 2026-02-04 22:38:43
// 
// Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: NCO
// Source Path: wlanhdlTimeAndFrequencySynchronization/WLANTimeAndFrequencySynchronization/Coarse CFO Estimation 
// and Correction/Coarse CFO Correction/NC
// Hierarchy Level: 3
// Model version: 9.2
// 
// NCO
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module NCO
          (clk,
           reset,
           enb_1_8_0,
           inc,
           validIn,
           complexexp_re,
           complexexp_im,
           validOut);


  input   clk;
  input   reset;
  input   enb_1_8_0;
  input   [15:0] inc;  // uint16
  input   validIn;
  output  signed [15:0] complexexp_re;  // sfix16_En14
  output  signed [15:0] complexexp_im;  // sfix16_En14
  output  validOut;


  reg  [4:0] outsel_reg_reg;  // ufix1 [5]
  wire outsel;
  wire signed [15:0] outzero_re;  // sfix16_En14
  wire signed [15:0] outzero_im;  // sfix16_En14
  wire signed [15:0] const0;  // sfix16
  wire signed [15:0] pInc;  // sfix16
  wire signed [15:0] validPInc;  // sfix16
  reg signed [15:0] accphase_reg;  // sfix16
  wire signed [15:0] addpInc;  // sfix16
  wire signed [15:0] pOffset;  // sfix16
  wire signed [15:0] accoffset;  // sfix16
  reg signed [15:0] accoffsete_reg;  // sfix16
  wire signed [15:0] outs_re;  // sfix16_En14
  wire signed [15:0] outs_im;  // sfix16_En14
  wire signed [15:0] validouts_re;  // sfix16_En14
  wire signed [15:0] validouts_im;  // sfix16_En14
  reg signed [15:0] complexexp_re_1;  // sfix16_En14
  reg signed [15:0] complexexp_im_1;  // sfix16_En14
  reg  validOut_1;


  always @(posedge clk or posedge reset)
    begin : outsel_reg_process
      if (reset == 1'b1) begin
        outsel_reg_reg <= {5{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          outsel_reg_reg[0] <= validIn;
          outsel_reg_reg[32'sd4:32'sd1] <= outsel_reg_reg[32'sd3:32'sd0];
        end
      end
    end

  assign outsel = outsel_reg_reg[4];

  assign outzero_re = 16'sb0000000000000000;
  assign outzero_im = 16'sb0000000000000000;

  // Constant Zero
  assign const0 = 16'sb0000000000000000;

  assign pInc = inc;

  assign validPInc = (validIn == 1'b0 ? const0 :
              pInc);

  // Add phase increment
  assign addpInc = accphase_reg + validPInc;

  // Phase increment accumulator register
  always @(posedge clk or posedge reset)
    begin : AccPhaseRegister_process
      if (reset == 1'b1) begin
        accphase_reg <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_8_0) begin
          accphase_reg <= addpInc;
        end
      end
    end

  assign pOffset = 16'sb0000000000000000;

  // Add phase offset
  assign accoffset = accphase_reg + pOffset;

  // Phase offset accumulator register
  always @(posedge clk or posedge reset)
    begin : AccOffsetRegister_process
      if (reset == 1'b1) begin
        accoffsete_reg <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_8_0) begin
          accoffsete_reg <= accoffset;
        end
      end
    end

  WaveformGen u_Wave_inst (.clk(clk),
                           .reset(reset),
                           .enb_1_8_0(enb_1_8_0),
                           .phaseIdx(accoffsete_reg),  // sfix16
                           .exp_re(outs_re),  // sfix16_En14
                           .exp_im(outs_im)  // sfix16_En14
                           );

  assign validouts_re = (outsel == 1'b0 ? outzero_re :
              outs_re);
  assign validouts_im = (outsel == 1'b0 ? outzero_im :
              outs_im);

  // Output register
  always @(posedge clk or posedge reset)
    begin : OutputRegister_process
      if (reset == 1'b1) begin
        complexexp_re_1 <= 16'sb0000000000000000;
        complexexp_im_1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_8_0) begin
          complexexp_re_1 <= validouts_re;
          complexexp_im_1 <= validouts_im;
        end
      end
    end

  // validOut register
  always @(posedge clk or posedge reset)
    begin : validOut_reg_process
      if (reset == 1'b1) begin
        validOut_1 <= 1'b0;
      end
      else begin
        if (enb_1_8_0) begin
          validOut_1 <= outsel;
        end
      end
    end

  assign complexexp_re = complexexp_re_1;

  assign complexexp_im = complexexp_im_1;

  assign validOut = validOut_1;

endmodule  // NCO

