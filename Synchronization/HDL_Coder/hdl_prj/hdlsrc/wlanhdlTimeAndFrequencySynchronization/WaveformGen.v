// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/wlanhdlTimeAndFrequencySynchronization/WaveformGen.v
// Created: 2026-02-04 22:38:43
// 
// Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: WaveformGen
// Source Path: wlanhdlTimeAndFrequencySynchronization/WLANTimeAndFrequencySynchronization/Coarse CFO Estimation 
// and Correction/Coarse CFO Correction/NCO/WaveformGe
// Hierarchy Level: 4
// Model version: 9.2
// 
// Wave form Generation Component
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module WaveformGen
          (clk,
           reset,
           enb_1_8_0,
           phaseIdx,
           exp_re,
           exp_im);


  input   clk;
  input   reset;
  input   enb_1_8_0;
  input   [15:0] phaseIdx;  // ufix16
  output  signed [15:0] exp_re;  // sfix16_En14
  output  signed [15:0] exp_im;  // sfix16_En14


  reg [15:0] phaseIdxReg;  // ufix16
  wire msb1;  // ufix1
  wire msb2;  // ufix1
  wire signSel;  // ufix1
  reg  [2:0] signSelRegComp_reg;  // ufix1 [3]
  wire signSelReg;  // ufix1
  wire [13:0] lutaddr1;  // ufix14
  wire sin45Sel;  // ufix1
  reg  [2:0] sin45SelRegComp_reg;  // ufix1 [3]
  wire sin45SelReg;  // ufix1
  wire msb3;  // ufix1
  wire lutSel;  // ufix1
  reg  [2:0] lutSelRegComp_reg;  // ufix1 [3]
  wire lutSelReg;  // ufix1
  wire [14:0] lutaddrmax;  // ufix15
  wire [15:0] subtractor_sub_temp;  // ufix16
  wire [15:0] subtractor_1;  // ufix16
  wire [15:0] subtractor_2;  // ufix16
  wire [13:0] lutaddr2;  // ufix14
  wire [13:0] lutaddr;  // ufix14
  wire [12:0] lutaddrO;  // ufix13
  wire signed [15:0] lutoutcos;  // sfix16_En14
  wire signed [15:0] lutoutsin;  // sfix16_En14
  wire signed [15:0] lutselcos;  // sfix16_En14
  wire signed [15:0] octantVal;  // sfix16_En14
  wire signed [15:0] fullcosmag;  // sfix16_En14
  wire signed [16:0] uminus_cast;  // sfix17_En14
  wire signed [16:0] uminus_cast_1;  // sfix17_En14
  wire signed [15:0] inverseCos;  // sfix16_En14
  wire signed [15:0] cosout;  // sfix16_En14
  reg  [2:0] sineSignSelRegComp_reg;  // ufix1 [3]
  wire sineSignSelReg;  // ufix1
  wire signed [15:0] lutselsin;  // sfix16_En14
  wire signed [15:0] fullsinmag;  // sfix16_En14
  wire signed [16:0] uminus_cast_2;  // sfix17_En14
  wire signed [16:0] uminus_cast_3;  // sfix17_En14
  wire signed [15:0] inverseSin;  // sfix16_En14
  wire signed [15:0] sinout;  // sfix16_En14


  always @(posedge clk or posedge reset)
    begin : phaseIdxRegister_process
      if (reset == 1'b1) begin
        phaseIdxReg <= 16'b0000000000000000;
      end
      else begin
        if (enb_1_8_0) begin
          phaseIdxReg <= phaseIdx;
        end
      end
    end

  // Sine sign selection signal
  assign msb1 = phaseIdxReg[15];

  assign msb2 = phaseIdxReg[14];

  // Cosine sign selection signal
  assign signSel = msb1 ^ msb2;

  always @(posedge clk or posedge reset)
    begin : signSelRegComp_process
      if (reset == 1'b1) begin
        signSelRegComp_reg <= {3{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          signSelRegComp_reg[0] <= signSel;
          signSelRegComp_reg[32'sd2:32'sd1] <= signSelRegComp_reg[32'sd1:32'sd0];
        end
      end
    end

  assign signSelReg = signSelRegComp_reg[2];

  assign lutaddr1 = phaseIdxReg[13:0];

  // 45 degree address
  assign sin45Sel = lutaddr1 == 14'b10000000000000;

  always @(posedge clk or posedge reset)
    begin : sin45SelRegComp_process
      if (reset == 1'b1) begin
        sin45SelRegComp_reg <= {3{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          sin45SelRegComp_reg[0] <= sin45Sel;
          sin45SelRegComp_reg[32'sd2:32'sd1] <= sin45SelRegComp_reg[32'sd1:32'sd0];
        end
      end
    end

  assign sin45SelReg = sin45SelRegComp_reg[2];

  assign msb3 = phaseIdxReg[13];

  // LUT selection signal
  assign lutSel = msb2 ^ msb3;

  always @(posedge clk or posedge reset)
    begin : lutSelRegComp_process
      if (reset == 1'b1) begin
        lutSelRegComp_reg <= {3{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          lutSelRegComp_reg[0] <= lutSel;
          lutSelRegComp_reg[32'sd2:32'sd1] <= lutSelRegComp_reg[32'sd1:32'sd0];
        end
      end
    end

  assign lutSelReg = lutSelRegComp_reg[2];

  // Map LUT address in correct phase
  assign lutaddrmax = 15'b100000000000000;

  assign subtractor_1 = {1'b0, lutaddrmax};
  assign subtractor_2 = {2'b0, lutaddr1};
  assign subtractor_sub_temp = subtractor_1 - subtractor_2;
  assign lutaddr2 = subtractor_sub_temp[13:0];

  assign lutaddr = (msb3 == 1'b0 ? lutaddr1 :
              lutaddr2);

  assign lutaddrO = lutaddr[12:0];

  CosLookUpTableGen u_Cos_Wave_inst (.clk(clk),
                                     .reset(reset),
                                     .enb_1_8_0(enb_1_8_0),
                                     .lutaddr(lutaddrO),  // ufix13
                                     .lutCosine(lutoutcos)  // sfix16_En14
                                     );

  SinLookUpTableGen u_Sin_Wave_inst (.clk(clk),
                                     .reset(reset),
                                     .enb_1_8_0(enb_1_8_0),
                                     .lutaddr(lutaddrO),  // ufix13
                                     .lutSine(lutoutsin)  // sfix16_En14
                                     );

  // Select cosine output LUT
  assign lutselcos = (lutSelReg == 1'b0 ? lutoutcos :
              lutoutsin);

  assign octantVal = 16'sb0010110101000001;

  // Assign cosine pi/4 value
  assign fullcosmag = (sin45SelReg == 1'b0 ? lutselcos :
              octantVal);

  assign uminus_cast = {fullcosmag[15], fullcosmag};
  assign uminus_cast_1 =  - (uminus_cast);
  assign inverseCos = uminus_cast_1[15:0];

  // Select sign of cosine ouptput
  assign cosout = (signSelReg == 1'b0 ? fullcosmag :
              inverseCos);

  assign exp_re = cosout;

  always @(posedge clk or posedge reset)
    begin : sineSignSelRegComp_process
      if (reset == 1'b1) begin
        sineSignSelRegComp_reg <= {3{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          sineSignSelRegComp_reg[0] <= msb1;
          sineSignSelRegComp_reg[32'sd2:32'sd1] <= sineSignSelRegComp_reg[32'sd1:32'sd0];
        end
      end
    end

  assign sineSignSelReg = sineSignSelRegComp_reg[2];

  // Select sine output LUT
  assign lutselsin = (lutSelReg == 1'b0 ? lutoutsin :
              lutoutcos);

  // Assign sine pi/4 value
  assign fullsinmag = (sin45SelReg == 1'b0 ? lutselsin :
              octantVal);

  assign uminus_cast_2 = {fullsinmag[15], fullsinmag};
  assign uminus_cast_3 =  - (uminus_cast_2);
  assign inverseSin = uminus_cast_3[15:0];

  // Select sign of sine output
  assign sinout = (sineSignSelReg == 1'b0 ? fullsinmag :
              inverseSin);

  assign exp_im = sinout;

endmodule  // WaveformGen

