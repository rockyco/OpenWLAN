// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/wlanhdlTimeAndFrequencySynchronization/Averager.v
// Created: 2026-02-04 22:38:43
// 
// Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Averager
// Source Path: wlanhdlTimeAndFrequencySynchronization/WLANTimeAndFrequencySynchronization/Coarse CFO Estimation 
// and Correction/Coarse CFO Estimation/Average
// Hierarchy Level: 3
// Model version: 9.2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Averager
          (clk,
           reset,
           enb_1_8_1,
           enb,
           corrIn_re,
           corrIn_im,
           load,
           rst,
           avgCorr_re,
           avgCorr_im,
           validOut);


  input   clk;
  input   reset;
  input   enb_1_8_1;
  input   enb;
  input   signed [30:0] corrIn_re;  // sfix31_En19
  input   signed [30:0] corrIn_im;  // sfix31_En19
  input   load;
  input   rst;
  output  signed [30:0] avgCorr_re;  // sfix31_En19
  output  signed [30:0] avgCorr_im;  // sfix31_En19
  output  validOut;


  wire signed [30:0] corrIn_re_1;  // sfix31_En19
  wire signed [30:0] corrIn_im_1;  // sfix31_En19
  reg signed [30:0] corrIn_re_2;  // sfix31_En19
  reg signed [30:0] corrIn_im_2;  // sfix31_En19
  wire rst_1;
  reg  rst_2;
  wire load_1;
  reg  [3:0] rd_1_reg;  // ufix1 [4]
  wire load_2;
  wire [15:0] count_step;  // uint16
  wire [15:0] count_from;  // uint16
  wire [15:0] Constant_out1;  // uint16
  wire [15:0] count_reset;  // uint16
  reg [15:0] HDL_Counter_out1;  // uint16
  wire [15:0] count;  // uint16
  reg [15:0] count_1;  // uint16
  wire need_to_wrap;
  reg  need_to_wrap_1;
  wire [15:0] count_value;  // uint16
  reg [15:0] count_value_1;  // uint16
  reg [15:0] rd_5_reg [0:1];  // ufix16 [2]
  wire [15:0] rd_5_reg_next [0:1];  // ufix16 [2]
  wire [15:0] HDL_Counter_out1_1;  // uint16
  wire Compare_To_Zero_out1;
  reg  [1:0] rd_6_reg;  // ufix1 [2]
  wire Compare_To_Zero_out1_1;
  wire [15:0] count_2;  // uint16
  reg [15:0] count_3;  // uint16
  wire [15:0] count_4;  // uint16
  wire Compare_To_Constant_out1;
  wire Logical_Operator1_out1;
  reg  [2:0] rd_8_reg;  // ufix1 [3]
  wire Logical_Operator1_out1_1;
  wire [15:0] count_5;  // uint16
  reg [15:0] count_6;  // uint16
  reg [15:0] HDL_Counter_bypass_reg;  // ufix16
  wire [15:0] HDL_Counter_out1_2;  // uint16
  wire [15:0] HDL_Counter_out1_3;  // uint16
  wire Compare_To_Constant2_out1;
  reg  Compare_To_Constant2_out1_1;
  wire Compare_To_Constant1_out1;
  reg  Compare_To_Constant1_out1_1;
  wire Logical_Operator_out1;
  wire signed [30:0] Constant1_out1_re;  // sfix31_En19
  wire signed [30:0] Constant1_out1_im;  // sfix31_En19
  wire signed [30:0] Delay_out1_im;  // sfix31_En19
  wire signed [30:0] Delay_out1_im_1;  // sfix31_En19
  wire signed [30:0] Sum_out1_re;  // sfix31_En19
  wire signed [30:0] Sum_out1_im;  // sfix31_En19
  reg signed [30:0] Sum_out1_re_1;  // sfix31_En19
  reg signed [30:0] Sum_out1_im_1;  // sfix31_En19
  wire signed [30:0] Switch_out1_re;  // sfix31_En19
  wire signed [30:0] Switch_out1_im;  // sfix31_En19
  reg signed [30:0] Switch_out1_re_1;  // sfix31_En19
  reg signed [30:0] Switch_out1_im_1;  // sfix31_En19
  reg signed [30:0] Delay_bypass_reg_re;  // sfix31_En19
  reg signed [30:0] Delay_bypass_reg_im;  // sfix31_En19
  wire signed [30:0] Delay_out1_re;  // sfix31_En19
  wire signed [30:0] Delay_out1_re_1;  // sfix31_En19
  reg signed [30:0] Delay_out1_re_2;  // sfix31_En19
  reg signed [30:0] Delay_out1_im_2;  // sfix31_En19
  wire Compare_To_Constant3_out1;
  reg signed [31:0] rd_5_t_0_0;  // int32
  reg signed [31:0] rd_5_t_1;  // int32


  assign corrIn_re_1 = corrIn_re;

  assign corrIn_im_1 = corrIn_im;

  always @(posedge clk or posedge reset)
    begin : rd_13_process
      if (reset == 1'b1) begin
        corrIn_re_2 <= 31'sb0000000000000000000000000000000;
        corrIn_im_2 <= 31'sb0000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          corrIn_re_2 <= corrIn_re_1;
          corrIn_im_2 <= corrIn_im_1;
        end
      end
    end

  assign rst_1 = rst;

  always @(posedge clk or posedge reset)
    begin : rd_0_process
      if (reset == 1'b1) begin
        rst_2 <= 1'b0;
      end
      else begin
        if (enb) begin
          rst_2 <= rst_1;
        end
      end
    end

  assign load_1 = load;

  always @(posedge clk or posedge reset)
    begin : rd_1_process
      if (reset == 1'b1) begin
        rd_1_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          rd_1_reg[0] <= load_1;
          rd_1_reg[32'sd3:32'sd1] <= rd_1_reg[32'sd2:32'sd0];
        end
      end
    end

  assign load_2 = rd_1_reg[3];

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 159
  assign count_step = 16'b0000000000000001;

  assign count_from = 16'b0000000000000000;

  assign Constant_out1 = 16'b0000000000000001;

  assign count_reset = 16'b0000000000000000;

  assign count = HDL_Counter_out1 + count_step;

  always @(posedge clk or posedge reset)
    begin : rd_2_process
      if (reset == 1'b1) begin
        count_1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_1 <= count;
        end
      end
    end

  assign need_to_wrap = HDL_Counter_out1 == 16'b0000000010011111;

  always @(posedge clk or posedge reset)
    begin : rd_3_process
      if (reset == 1'b1) begin
        need_to_wrap_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          need_to_wrap_1 <= need_to_wrap;
        end
      end
    end

  assign count_value = (need_to_wrap_1 == 1'b0 ? count_1 :
              count_from);

  always @(posedge clk or posedge reset)
    begin : rd_4_process
      if (reset == 1'b1) begin
        count_value_1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_value_1 <= count_value;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rd_5_process
      if (reset == 1'b1) begin
        for(rd_5_t_1 = 32'sd0; rd_5_t_1 <= 32'sd1; rd_5_t_1 = rd_5_t_1 + 32'sd1) begin
          rd_5_reg[rd_5_t_1] <= 16'b0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_5_t_0_0 = 32'sd0; rd_5_t_0_0 <= 32'sd1; rd_5_t_0_0 = rd_5_t_0_0 + 32'sd1) begin
            rd_5_reg[rd_5_t_0_0] <= rd_5_reg_next[rd_5_t_0_0];
          end
        end
      end
    end

  assign HDL_Counter_out1_1 = rd_5_reg[1];
  assign rd_5_reg_next[0] = HDL_Counter_out1;
  assign rd_5_reg_next[1] = rd_5_reg[0];

  assign Compare_To_Zero_out1 = HDL_Counter_out1 > 16'b0000000000000000;

  always @(posedge clk or posedge reset)
    begin : rd_6_process
      if (reset == 1'b1) begin
        rd_6_reg <= {2{1'b0}};
      end
      else begin
        if (enb) begin
          rd_6_reg[0] <= Compare_To_Zero_out1;
          rd_6_reg[1] <= rd_6_reg[0];
        end
      end
    end

  assign Compare_To_Zero_out1_1 = rd_6_reg[1];

  assign count_2 = (Compare_To_Zero_out1_1 == 1'b0 ? HDL_Counter_out1_1 :
              count_value_1);

  always @(posedge clk or posedge reset)
    begin : rd_7_process
      if (reset == 1'b1) begin
        count_3 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_3 <= count_2;
        end
      end
    end

  assign count_4 = (load_2 == 1'b0 ? count_3 :
              Constant_out1);

  assign Compare_To_Constant_out1 = HDL_Counter_out1 == 16'b0000000010011111;

  assign Logical_Operator1_out1 = Compare_To_Constant_out1 | rst_2;

  always @(posedge clk or posedge reset)
    begin : rd_8_process
      if (reset == 1'b1) begin
        rd_8_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          rd_8_reg[0] <= Logical_Operator1_out1;
          rd_8_reg[32'sd2:32'sd1] <= rd_8_reg[32'sd1:32'sd0];
        end
      end
    end

  assign Logical_Operator1_out1_1 = rd_8_reg[2];

  assign count_5 = (Logical_Operator1_out1_1 == 1'b0 ? count_4 :
              count_reset);

  always @(posedge clk or posedge reset)
    begin : rd_9_process
      if (reset == 1'b1) begin
        count_6 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_6 <= count_5;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : HDL_Counter_bypass_process
      if (reset == 1'b1) begin
        HDL_Counter_bypass_reg <= 16'b0000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          HDL_Counter_bypass_reg <= count_6;
        end
      end
    end

  assign HDL_Counter_out1_2 = (enb_1_8_1 == 1'b1 ? count_6 :
              HDL_Counter_bypass_reg);

  assign HDL_Counter_out1_3 = HDL_Counter_out1_2;

  always @(posedge clk or posedge reset)
    begin : rd_10_process
      if (reset == 1'b1) begin
        HDL_Counter_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          HDL_Counter_out1 <= HDL_Counter_out1_3;
        end
      end
    end

  assign Compare_To_Constant2_out1 = HDL_Counter_out1 <= 16'b0000000010001011;

  always @(posedge clk or posedge reset)
    begin : rd_11_process
      if (reset == 1'b1) begin
        Compare_To_Constant2_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Compare_To_Constant2_out1_1 <= Compare_To_Constant2_out1;
        end
      end
    end

  assign Compare_To_Constant1_out1 = HDL_Counter_out1 >= 16'b0000000000001100;

  always @(posedge clk or posedge reset)
    begin : rd_12_process
      if (reset == 1'b1) begin
        Compare_To_Constant1_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Compare_To_Constant1_out1_1 <= Compare_To_Constant1_out1;
        end
      end
    end

  assign Logical_Operator_out1 = Compare_To_Constant2_out1_1 & Compare_To_Constant1_out1_1;

  assign Constant1_out1_re = 31'sb0000000000000000000000000000000;
  assign Constant1_out1_im = 31'sb0000000000000000000000000000000;

  assign Delay_out1_im_1 = Delay_out1_im;

  always @(posedge clk or posedge reset)
    begin : rd_14_process
      if (reset == 1'b1) begin
        Sum_out1_re_1 <= 31'sb0000000000000000000000000000000;
        Sum_out1_im_1 <= 31'sb0000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Sum_out1_re_1 <= Sum_out1_re;
          Sum_out1_im_1 <= Sum_out1_im;
        end
      end
    end

  assign Switch_out1_re = (Logical_Operator_out1 == 1'b0 ? Constant1_out1_re :
              Sum_out1_re_1);
  assign Switch_out1_im = (Logical_Operator_out1 == 1'b0 ? Constant1_out1_im :
              Sum_out1_im_1);

  always @(posedge clk or posedge reset)
    begin : rd_15_process
      if (reset == 1'b1) begin
        Switch_out1_re_1 <= 31'sb0000000000000000000000000000000;
        Switch_out1_im_1 <= 31'sb0000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Switch_out1_re_1 <= Switch_out1_re;
          Switch_out1_im_1 <= Switch_out1_im;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay_bypass_process
      if (reset == 1'b1) begin
        Delay_bypass_reg_re <= 31'sb0000000000000000000000000000000;
        Delay_bypass_reg_im <= 31'sb0000000000000000000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Delay_bypass_reg_im <= Switch_out1_im_1;
          Delay_bypass_reg_re <= Switch_out1_re_1;
        end
      end
    end

  assign Delay_out1_re = (enb_1_8_1 == 1'b1 ? Switch_out1_re_1 :
              Delay_bypass_reg_re);
  assign Delay_out1_im = (enb_1_8_1 == 1'b1 ? Switch_out1_im_1 :
              Delay_bypass_reg_im);

  assign Delay_out1_re_1 = Delay_out1_re;

  always @(posedge clk or posedge reset)
    begin : rd_16_process
      if (reset == 1'b1) begin
        Delay_out1_re_2 <= 31'sb0000000000000000000000000000000;
        Delay_out1_im_2 <= 31'sb0000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Delay_out1_re_2 <= Delay_out1_re_1;
          Delay_out1_im_2 <= Delay_out1_im_1;
        end
      end
    end

  assign Sum_out1_re = corrIn_re_2 + Delay_out1_re_2;
  assign Sum_out1_im = corrIn_im_2 + Delay_out1_im_2;

  assign avgCorr_re = Sum_out1_re;

  assign avgCorr_im = Sum_out1_im;

  assign Compare_To_Constant3_out1 = HDL_Counter_out1 == 16'b0000000010001011;

  assign validOut = Compare_To_Constant3_out1;

endmodule  // Averager

