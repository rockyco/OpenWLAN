// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/wlanhdlTimeAndFrequencySynchronization/maxPeakSearcher_block.v
// Created: 2026-02-04 22:38:44
// 
// Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: maxPeakSearcher_block
// Source Path: wlanhdlTimeAndFrequencySynchronization/WLANTimeAndFrequencySynchronization/Fine Time Sync/Peak Searcher/maxPeakSearcher
// Hierarchy Level: 3
// Model version: 9.2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module maxPeakSearcher_block
          (clk,
           reset,
           enb_1_8_1,
           enb_1_8_0,
           enb,
           corrIn,
           corrValid,
           startIn,
           validIn,
           dataIn_re,
           dataIn_im,
           rstIn,
           maxPeakValue,
           countRst,
           dataOut_re,
           dataOut_im,
           validOut);


  input   clk;
  input   reset;
  input   enb_1_8_1;
  input   enb_1_8_0;
  input   enb;
  input   signed [31:0] corrIn;  // sfix32_En15
  input   corrValid;
  input   startIn;
  input   validIn;
  input   signed [15:0] dataIn_re;  // sfix16_En12
  input   signed [15:0] dataIn_im;  // sfix16_En12
  input   rstIn;
  output  [15:0] maxPeakValue;  // uint16
  output  countRst;
  output  signed [15:0] dataOut_re;  // sfix16_En12
  output  signed [15:0] dataOut_im;  // sfix16_En12
  output  validOut;


  wire signed [31:0] corrIn_1;  // sfix32_En15
  reg signed [31:0] corrIn_2;  // sfix32_En15
  reg signed [31:0] Delay27_out1;  // sfix32_En15
  wire signed [31:0] Delay27_out1_1;  // sfix32_En15
  reg signed [31:0] maxPeakSearcher1_bypass_reg;  // sfix32
  wire signed [31:0] Delay27_out1_2;  // sfix32_En15
  wire rstIn_1;
  reg  rstIn_2;
  wire startIn_1;
  reg  startIn_2;
  wire Logical_Operator_out1;
  wire extractLTFs_valid;
  wire [15:0] extractLTFs_count;  // uint16
  reg  extractLTFs_valid_1;
  reg  Delay28_bypass_reg;  // ufix1
  wire Delay28_out1;
  reg [15:0] extractLTFs_count_1;  // uint16
  reg [15:0] Delay29_bypass_reg;  // ufix16
  wire [15:0] Delay29_out1;  // uint16
  reg  Logical_Operator_out1_1;
  reg  Logical_Operator_out1_2;
  reg  [157:0] Delay9_reg;  // ufix1 [158]
  wire Delay9_out1;
  wire Delay9_out1_1;
  reg  Delay9_out1_2;
  reg  Delay30_out1;
  wire [15:0] maxPeak;  // uint16
  reg  Delay9_out1_3;
  reg  [129:0] Delay8_reg;  // ufix1 [130]
  wire Delay8_out1;
  wire signed [15:0] dataIn_re_1;  // sfix16_En12
  wire signed [15:0] dataIn_im_1;  // sfix16_En12
  reg signed [15:0] dataIn_re_2;  // sfix16_En12
  reg signed [15:0] dataIn_im_2;  // sfix16_En12
  reg signed [15:0] Delay1_reg_re [0:158];  // sfix16_En12 [159]
  reg signed [15:0] Delay1_reg_im [0:158];  // sfix16_En12 [159]
  reg signed [15:0] Delay1_reg_next_re [0:158];  // sfix16_En12 [159]
  reg signed [15:0] Delay1_reg_next_im [0:158];  // sfix16_En12 [159]
  reg signed [15:0] Delay1_out1_re;  // sfix16_En12
  reg signed [15:0] Delay1_out1_im;  // sfix16_En12
  wire signed [15:0] Delay1_out1_re_1;  // sfix16_En12
  wire signed [15:0] Delay1_out1_im_1;  // sfix16_En12
  reg signed [15:0] Delay1_out1_re_2;  // sfix16_En12
  reg signed [15:0] Delay1_out1_im_2;  // sfix16_En12
  reg signed [15:0] Delay4_reg_re [0:129];  // sfix16_En12 [130]
  reg signed [15:0] Delay4_reg_im [0:129];  // sfix16_En12 [130]
  reg signed [15:0] Delay4_reg_next_re [0:129];  // sfix16_En12 [130]
  reg signed [15:0] Delay4_reg_next_im [0:129];  // sfix16_En12 [130]
  reg signed [15:0] Delay4_out1_re;  // sfix16_En12
  reg signed [15:0] Delay4_out1_im;  // sfix16_En12
  wire validIn_1;
  reg  validIn_2;
  reg  [158:0] Delay3_reg;  // ufix1 [159]
  wire Delay3_out1;
  wire Delay3_out1_1;
  reg  Delay3_out1_2;
  reg  [129:0] Delay6_reg;  // ufix1 [130]
  wire Delay6_out1;
  reg signed [31:0] Delay1_t_0_0;  // int32
  reg signed [31:0] Delay1_t_0_1;  // int32
  reg signed [31:0] Delay1_t_1;  // int32
  reg signed [31:0] Delay4_t_0_0;  // int32
  reg signed [31:0] Delay4_t_0_1;  // int32
  reg signed [31:0] Delay4_t_1;  // int32


  assign corrIn_1 = corrIn;

  always @(posedge clk or posedge reset)
    begin : Delay271_output_process
      if (reset == 1'b1) begin
        corrIn_2 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          corrIn_2 <= corrIn_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay27_process
      if (reset == 1'b1) begin
        Delay27_out1 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb_1_8_0) begin
          Delay27_out1 <= corrIn_2;
        end
      end
    end

  assign Delay27_out1_1 = Delay27_out1;

  always @(posedge clk or posedge reset)
    begin : maxPeakSearcher1_bypass_process
      if (reset == 1'b1) begin
        maxPeakSearcher1_bypass_reg <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          maxPeakSearcher1_bypass_reg <= Delay27_out1_1;
        end
      end
    end

  assign Delay27_out1_2 = (enb_1_8_1 == 1'b1 ? Delay27_out1_1 :
              maxPeakSearcher1_bypass_reg);

  assign rstIn_1 = rstIn;

  always @(posedge clk or posedge reset)
    begin : rd_3_process
      if (reset == 1'b1) begin
        rstIn_2 <= 1'b0;
      end
      else begin
        if (enb) begin
          rstIn_2 <= rstIn_1;
        end
      end
    end

  assign startIn_1 = startIn;

  always @(posedge clk or posedge reset)
    begin : rd_4_process
      if (reset == 1'b1) begin
        startIn_2 <= 1'b0;
      end
      else begin
        if (enb) begin
          startIn_2 <= startIn_1;
        end
      end
    end

  assign Logical_Operator_out1 = rstIn_2 | startIn_2;

  extractLTFs u_extractLTFs (.clk(clk),
                             .reset(reset),
                             .enb_1_8_1(enb_1_8_1),
                             .enb(enb),
                             .enb_1(corrValid),
                             .rst(Logical_Operator_out1),
                             .valid(extractLTFs_valid),
                             .count(extractLTFs_count)  // uint16
                             );

  always @(posedge clk or posedge reset)
    begin : crp_out_delay1_process
      if (reset == 1'b1) begin
        extractLTFs_valid_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          extractLTFs_valid_1 <= extractLTFs_valid;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay28_bypass_process
      if (reset == 1'b1) begin
        Delay28_bypass_reg <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay28_bypass_reg <= extractLTFs_valid_1;
        end
      end
    end

  assign Delay28_out1 = (enb_1_8_1 == 1'b1 ? extractLTFs_valid_1 :
              Delay28_bypass_reg);

  always @(posedge clk or posedge reset)
    begin : crp_out_delay2_process
      if (reset == 1'b1) begin
        extractLTFs_count_1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          extractLTFs_count_1 <= extractLTFs_count;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay29_bypass_process
      if (reset == 1'b1) begin
        Delay29_bypass_reg <= 16'b0000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Delay29_bypass_reg <= extractLTFs_count_1;
        end
      end
    end

  assign Delay29_out1 = (enb_1_8_1 == 1'b1 ? extractLTFs_count_1 :
              Delay29_bypass_reg);

  always @(posedge clk or posedge reset)
    begin : crp_out_delay_process
      if (reset == 1'b1) begin
        Logical_Operator_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Logical_Operator_out1_1 <= Logical_Operator_out1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay91_output_process
      if (reset == 1'b1) begin
        Logical_Operator_out1_2 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Logical_Operator_out1_2 <= Logical_Operator_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay9_process
      if (reset == 1'b1) begin
        Delay9_reg <= {158{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay9_reg[0] <= Logical_Operator_out1_2;
          Delay9_reg[32'sd157:32'sd1] <= Delay9_reg[32'sd156:32'sd0];
        end
      end
    end

  assign Delay9_out1 = Delay9_reg[157];

  assign Delay9_out1_1 = Delay9_out1;

  always @(posedge clk or posedge reset)
    begin : Delay301_output_process
      if (reset == 1'b1) begin
        Delay9_out1_2 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay9_out1_2 <= Delay9_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay30_process
      if (reset == 1'b1) begin
        Delay30_out1 <= 1'b0;
      end
      else begin
        if (enb_1_8_0) begin
          Delay30_out1 <= Delay9_out1_2;
        end
      end
    end

  maxPeakSearcher u_maxPeakSearcher (.clk(clk),
                                     .reset(reset),
                                     .enb_1_8_0(enb_1_8_0),
                                     .dataIn(Delay27_out1_2),  // sfix32_En15
                                     .validIn(Delay28_out1),
                                     .countValue(Delay29_out1),  // uint16
                                     .reset_1(Delay30_out1),
                                     .maxPeak(maxPeak)  // uint16
                                     );

  assign maxPeakValue = maxPeak;

  always @(posedge clk or posedge reset)
    begin : Delay312_output_process
      if (reset == 1'b1) begin
        Delay9_out1_3 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay9_out1_3 <= Delay9_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        Delay8_reg <= {130{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay8_reg[0] <= Delay9_out1_3;
          Delay8_reg[32'sd129:32'sd1] <= Delay8_reg[32'sd128:32'sd0];
        end
      end
    end

  assign Delay8_out1 = Delay8_reg[129];

  assign countRst = Delay8_out1;

  assign dataIn_re_1 = dataIn_re;

  assign dataIn_im_1 = dataIn_im;

  always @(posedge clk or posedge reset)
    begin : Delay11_output_process
      if (reset == 1'b1) begin
        dataIn_re_2 <= 16'sb0000000000000000;
        dataIn_im_2 <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          dataIn_re_2 <= dataIn_re_1;
          dataIn_im_2 <= dataIn_im_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        for(Delay1_t_1 = 32'sd0; Delay1_t_1 <= 32'sd158; Delay1_t_1 = Delay1_t_1 + 32'sd1) begin
          Delay1_reg_re[Delay1_t_1] <= 16'sb0000000000000000;
          Delay1_reg_im[Delay1_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb_1_8_0) begin
          for(Delay1_t_0_1 = 32'sd0; Delay1_t_0_1 <= 32'sd158; Delay1_t_0_1 = Delay1_t_0_1 + 32'sd1) begin
            Delay1_reg_re[Delay1_t_0_1] <= Delay1_reg_next_re[Delay1_t_0_1];
            Delay1_reg_im[Delay1_t_0_1] <= Delay1_reg_next_im[Delay1_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay1_out1_re = Delay1_reg_re[158];
    Delay1_out1_im = Delay1_reg_im[158];
    Delay1_reg_next_re[0] = dataIn_re_2;
    Delay1_reg_next_im[0] = dataIn_im_2;

    for(Delay1_t_0_0 = 32'sd0; Delay1_t_0_0 <= 32'sd157; Delay1_t_0_0 = Delay1_t_0_0 + 32'sd1) begin
      Delay1_reg_next_re[Delay1_t_0_0 + 32'sd1] = Delay1_reg_re[Delay1_t_0_0];
      Delay1_reg_next_im[Delay1_t_0_0 + 32'sd1] = Delay1_reg_im[Delay1_t_0_0];
    end

  end

  assign Delay1_out1_re_1 = Delay1_out1_re;

  assign Delay1_out1_im_1 = Delay1_out1_im;

  always @(posedge clk or posedge reset)
    begin : Delay21_output_process
      if (reset == 1'b1) begin
        Delay1_out1_re_2 <= 16'sb0000000000000000;
        Delay1_out1_im_2 <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Delay1_out1_re_2 <= Delay1_out1_re_1;
          Delay1_out1_im_2 <= Delay1_out1_im_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        for(Delay4_t_1 = 32'sd0; Delay4_t_1 <= 32'sd129; Delay4_t_1 = Delay4_t_1 + 32'sd1) begin
          Delay4_reg_re[Delay4_t_1] <= 16'sb0000000000000000;
          Delay4_reg_im[Delay4_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb_1_8_0) begin
          for(Delay4_t_0_1 = 32'sd0; Delay4_t_0_1 <= 32'sd129; Delay4_t_0_1 = Delay4_t_0_1 + 32'sd1) begin
            Delay4_reg_re[Delay4_t_0_1] <= Delay4_reg_next_re[Delay4_t_0_1];
            Delay4_reg_im[Delay4_t_0_1] <= Delay4_reg_next_im[Delay4_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay4_out1_re = Delay4_reg_re[129];
    Delay4_out1_im = Delay4_reg_im[129];
    Delay4_reg_next_re[0] = Delay1_out1_re_2;
    Delay4_reg_next_im[0] = Delay1_out1_im_2;

    for(Delay4_t_0_0 = 32'sd0; Delay4_t_0_0 <= 32'sd128; Delay4_t_0_0 = Delay4_t_0_0 + 32'sd1) begin
      Delay4_reg_next_re[Delay4_t_0_0 + 32'sd1] = Delay4_reg_re[Delay4_t_0_0];
      Delay4_reg_next_im[Delay4_t_0_0 + 32'sd1] = Delay4_reg_im[Delay4_t_0_0];
    end

  end

  assign dataOut_re = Delay4_out1_re;

  assign dataOut_im = Delay4_out1_im;

  assign validIn_1 = validIn;

  always @(posedge clk or posedge reset)
    begin : Delay31_output_process
      if (reset == 1'b1) begin
        validIn_2 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          validIn_2 <= validIn_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_reg <= {159{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay3_reg[0] <= validIn_2;
          Delay3_reg[32'sd158:32'sd1] <= Delay3_reg[32'sd157:32'sd0];
        end
      end
    end

  assign Delay3_out1 = Delay3_reg[158];

  assign Delay3_out1_1 = Delay3_out1;

  always @(posedge clk or posedge reset)
    begin : Delay321_output_process
      if (reset == 1'b1) begin
        Delay3_out1_2 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay3_out1_2 <= Delay3_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_reg <= {130{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay6_reg[0] <= Delay3_out1_2;
          Delay6_reg[32'sd129:32'sd1] <= Delay6_reg[32'sd128:32'sd0];
        end
      end
    end

  assign Delay6_out1 = Delay6_reg[129];

  assign validOut = Delay6_out1;

endmodule  // maxPeakSearcher_block

