// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/wlanhdlTimeAndFrequencySynchronization/Coarse_CFO_Correction.v
// Created: 2026-02-04 22:38:43
// 
// Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: Coarse_CFO_Correction
// Source Path: wlanhdlTimeAndFrequencySynchronization/WLANTimeAndFrequencySynchronization/Coarse CFO Estimation 
// and Correction/Coarse CFO Correctio
// Hierarchy Level: 2
// Model version: 9.2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module Coarse_CFO_Correction
          (clk,
           reset,
           enb_1_8_1,
           enb_1_8_0,
           enb,
           freq,
           dataIn_re,
           dataIn_im,
           validIn,
           lstfStartIn,
           rstIn,
           freqOut,
           dataOut_re,
           dataOut_im,
           validOut,
           lstfStartOut,
           rstOut);


  input   clk;
  input   reset;
  input   enb_1_8_1;
  input   enb_1_8_0;
  input   enb;
  input   signed [33:0] freq;  // sfix34_En33
  input   signed [15:0] dataIn_re;  // sfix16_En12
  input   signed [15:0] dataIn_im;  // sfix16_En12
  input   validIn;
  input   lstfStartIn;
  input   rstIn;
  output  signed [33:0] freqOut;  // sfix34_En33
  output  signed [15:0] dataOut_re;  // sfix16_En12
  output  signed [15:0] dataOut_im;  // sfix16_En12
  output  validOut;
  output  lstfStartOut;
  output  rstOut;


  reg signed [33:0] freq_1;  // sfix34_En33
  wire signed [33:0] Delay11_out1;  // sfix34_En33
  reg signed [33:0] Delay11_out1_1;  // sfix34_En33
  reg signed [33:0] Delay28_reg [0:7];  // sfix34 [8]
  reg signed [33:0] Delay28_reg_next [0:7];  // sfix34_En33 [8]
  reg signed [33:0] Delay28_out1;  // sfix34_En33
  wire signed [33:0] Delay28_out1_1;  // sfix34_En33
  reg signed [33:0] Delay28_out1_2;  // sfix34_En33
  reg signed [33:0] Delay29_reg [0:1];  // sfix34 [2]
  wire signed [33:0] Delay29_reg_next [0:1];  // sfix34_En33 [2]
  wire signed [33:0] Delay29_out1;  // sfix34_En33
  wire signed [33:0] Delay29_out1_1;  // sfix34_En33
  reg signed [33:0] Delay29_out1_2;  // sfix34_En33
  reg signed [33:0] Delay311_reg [0:2];  // sfix34 [3]
  reg signed [33:0] Delay311_reg_next [0:2];  // sfix34_En33 [3]
  reg signed [33:0] Delay31_out1;  // sfix34_En33
  reg signed [15:0] Delay8_out1_re;  // sfix16_En12
  reg signed [15:0] Delay8_out1_im;  // sfix16_En12
  wire signed [15:0] Delay8_out1_re_1;  // sfix16_En12
  wire signed [15:0] Delay8_out1_im_1;  // sfix16_En12
  reg signed [15:0] Delay8_out1_re_2;  // sfix16_En12
  reg signed [15:0] Delay8_out1_im_2;  // sfix16_En12
  reg signed [15:0] Delay7_reg_re [0:7];  // sfix16_En12 [8]
  reg signed [15:0] Delay7_reg_im [0:7];  // sfix16_En12 [8]
  reg signed [15:0] Delay7_reg_next_re [0:7];  // sfix16_En12 [8]
  reg signed [15:0] Delay7_reg_next_im [0:7];  // sfix16_En12 [8]
  reg signed [15:0] Delay7_out1_re;  // sfix16_En12
  reg signed [15:0] Delay7_out1_im;  // sfix16_En12
  wire signed [15:0] Delay7_out1_re_1;  // sfix16_En12
  wire signed [15:0] Delay7_out1_im_1;  // sfix16_En12
  reg signed [15:0] DTConverter1_bypass_reg_re;  // sfix16_En12
  reg signed [15:0] DTConverter1_bypass_reg_im;  // sfix16_En12
  wire signed [15:0] Delay7_out1_re_2;  // sfix16_En12
  wire signed [15:0] Delay7_out1_im_2;  // sfix16_En12
  reg signed [15:0] Delay7_out1_re_3;  // sfix16_En12
  reg signed [15:0] Delay7_out1_im_3;  // sfix16_En12
  reg signed [15:0] Delay2_reg_re [0:1];  // sfix16_En12 [2]
  reg signed [15:0] Delay2_reg_im [0:1];  // sfix16_En12 [2]
  wire signed [15:0] Delay2_reg_next_re [0:1];  // sfix16_En12 [2]
  wire signed [15:0] Delay2_reg_next_im [0:1];  // sfix16_En12 [2]
  wire signed [15:0] Delay2_out1_re;  // sfix16_En12
  wire signed [15:0] Delay2_out1_im;  // sfix16_En12
  wire signed [15:0] Delay2_out1_re_1;  // sfix16_En12
  wire signed [15:0] Delay2_out1_im_1;  // sfix16_En12
  reg signed [15:0] Delay2_out1_re_2;  // sfix16_En12
  reg signed [15:0] Delay2_out1_im_2;  // sfix16_En12
  reg signed [15:0] Product1_C2ReIm_1_C2ReIm_A;  // sfix16_En12
  wire signed [33:0] Delay6_out1;  // sfix34_En33
  wire signed [35:0] Data_Type_Conversion1_out1;  // sfix36_En18
  reg signed [35:0] Data_Type_Conversion1_out1_1;  // sfix36_En18
  wire switch_compare_1;
  wire signed [35:0] Shift_Arithmetic_out1;  // sfix36_En18
  wire signed [36:0] Abs_y;  // sfix37_En18
  wire signed [36:0] Abs_cast;  // sfix37_En18
  wire signed [35:0] Abs_out1;  // sfix36_En18
  wire [15:0] Data_Type_Conversion_out1;  // uint16
  reg [15:0] NCO1_bypass_reg;  // ufix16
  wire [15:0] Data_Type_Conversion_out1_1;  // uint16
  reg  Delay12_out1;
  wire Delay12_out1_1;
  reg  NCO2_bypass_reg;  // ufix1
  wire Delay12_out1_2;
  wire signed [15:0] NCO_out1_re;  // sfix16_En14
  wire signed [15:0] NCO_out1_im;  // sfix16_En14
  wire NCO_out2;
  reg signed [15:0] Delay13_reg_re [0:1];  // sfix16_En14 [2]
  reg signed [15:0] Delay13_reg_im [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Delay13_reg_next_re [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Delay13_reg_next_im [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Delay13_out1_re;  // sfix16_En14
  wire signed [15:0] Delay13_out1_im;  // sfix16_En14
  wire signed [15:0] Delay13_out1_re_1;  // sfix16_En14
  wire signed [15:0] Delay13_out1_im_1;  // sfix16_En14
  reg signed [15:0] Delay13_out1_re_2;  // sfix16_En14
  reg signed [15:0] Delay13_out1_im_2;  // sfix16_En14
  wire signed [16:0] conj_cast;  // sfix17_En14
  wire signed [16:0] conj_cast_1;  // sfix17_En14
  wire signed [15:0] complexConjugate_out1_re;  // sfix16_En14
  wire signed [15:0] complexConjugate_out1_im;  // sfix16_En14
  reg signed [15:0] complexConjugate_out1_re_1;  // sfix16_En14
  reg signed [15:0] complexConjugate_out1_im_1;  // sfix16_En14
  wire signed [15:0] Switch_out1_re;  // sfix16_En14
  wire signed [15:0] Switch_out1_im;  // sfix16_En14
  reg signed [15:0] Switch_out1_re_1;  // sfix16_En14
  reg signed [15:0] Switch_out1_im_1;  // sfix16_En14
  reg signed [15:0] Switch_out1_re_2;  // sfix16_En14
  reg signed [15:0] Switch_out1_im_2;  // sfix16_En14
  reg signed [15:0] Delay3_out1_re;  // sfix16_En14
  reg signed [15:0] Delay3_out1_im;  // sfix16_En14
  wire signed [15:0] Delay3_out1_re_1;  // sfix16_En14
  wire signed [15:0] Delay3_out1_im_1;  // sfix16_En14
  reg signed [15:0] Delay3_out1_re_2;  // sfix16_En14
  reg signed [15:0] Delay3_out1_im_2;  // sfix16_En14
  reg signed [15:0] Product1_C2ReIm_2_C2ReIm_A;  // sfix16_En14
  wire signed [31:0] Product1_Re_AC;  // sfix32_En26
  reg signed [31:0] HwModeRegister_reg [0:2];  // sfix32 [3]
  reg signed [31:0] HwModeRegister_reg_next [0:2];  // sfix32_En26 [3]
  reg signed [31:0] Product1_Re_AC_1;  // sfix32_En26
  reg signed [15:0] rd_11_reg [0:1];  // sfix16 [2]
  wire signed [15:0] rd_11_reg_next [0:1];  // sfix16_En12 [2]
  wire signed [15:0] Product1_C2ReIm_1_C2ReIm_B;  // sfix16_En12
  reg signed [15:0] Product1_C2ReIm_1_C2ReIm_B_1;  // sfix16_En12
  reg signed [15:0] Product1_C2ReIm_2_C2ReIm_B;  // sfix16_En14
  reg signed [15:0] reduced_reg [0:1];  // sfix16 [2]
  wire signed [15:0] reduced_reg_next [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Product1_C2ReIm_2_C2ReIm_B_1;  // sfix16_En14
  (* use_dsp  = "yes" *)   wire signed [31:0] mulOutput;  // sfix32_En26
  reg signed [31:0] mulOutput_1;  // sfix32_En26
  wire signed [32:0] MultiplyAdd_add_sub_cast;  // sfix33_En26
  wire signed [32:0] MultiplyAdd_add_sub_cast_1;  // sfix33_En26
  wire signed [32:0] mulOutput_2;  // sfix33_En26
  wire signed [31:0] Product1_Im_AD;  // sfix32_En26
  reg signed [31:0] HwModeRegister_reg_1 [0:2];  // sfix32 [3]
  reg signed [31:0] HwModeRegister_reg_next_1 [0:2];  // sfix32_En26 [3]
  reg signed [31:0] Product1_Im_AD_1;  // sfix32_En26
  reg signed [15:0] reduced_reg_1 [0:1];  // sfix16 [2]
  wire signed [15:0] reduced_reg_next_1 [0:1];  // sfix16_En14 [2]
  wire signed [15:0] Product1_C2ReIm_2_C2ReIm_A_1;  // sfix16_En14
  (* use_dsp  = "yes" *)   wire signed [31:0] mulOutput_3;  // sfix32_En26
  reg signed [31:0] mulOutput_4;  // sfix32_En26
  wire signed [32:0] MultiplyAdd1_add_add_cast;  // sfix33_En26
  wire signed [32:0] MultiplyAdd1_add_add_cast_1;  // sfix33_En26
  wire signed [32:0] mulOutput_5;  // sfix33_En26
  reg signed [32:0] mulOutput_6;  // sfix33_En26
  wire signed [31:0] mulOutput_7;  // sfix32_En26
  reg signed [32:0] mulOutput_8;  // sfix33_En26
  wire signed [31:0] mulOutput_9;  // sfix32_En26
  reg signed [31:0] Product1_out1_re;  // sfix32_En26
  reg signed [31:0] Product1_out1_im;  // sfix32_En26
  reg signed [31:0] Product1_out1_re_1;  // sfix32_En26
  reg signed [31:0] Product1_out1_im_1;  // sfix32_En26
  reg signed [31:0] Delay1_reg_re [0:1];  // sfix32_En26 [2]
  reg signed [31:0] Delay1_reg_im [0:1];  // sfix32_En26 [2]
  wire signed [31:0] Delay1_reg_next_re [0:1];  // sfix32_En26 [2]
  wire signed [31:0] Delay1_reg_next_im [0:1];  // sfix32_En26 [2]
  wire signed [31:0] Delay1_out1_re;  // sfix32_En26
  wire signed [31:0] Delay1_out1_im;  // sfix32_En26
  reg  [1:0] Delay14_reg;  // ufix1 [2]
  wire Delay14_out1;
  wire Delay14_out1_1;
  reg  Delay14_out1_2;
  reg  [1:0] Delay15_reg;  // ufix1 [2]
  wire Delay15_out1;
  wire Delay15_out1_1;
  reg  Delay15_out1_2;
  reg  [2:0] Delay17_reg;  // ufix1 [3]
  wire Delay17_out1;
  reg  Delay18_out1;
  wire Delay18_out1_1;
  reg  Delay18_out1_2;
  reg  [7:0] Delay20_reg;  // ufix1 [8]
  wire Delay20_out1;
  wire Delay20_out1_1;
  reg  Delay20_out1_2;
  reg  [1:0] Delay21_reg;  // ufix1 [2]
  wire Delay21_out1;
  wire Delay21_out1_1;
  reg  Delay21_out1_2;
  reg  [2:0] Delay23_reg;  // ufix1 [3]
  wire Delay23_out1;
  reg signed [31:0] Delay28_t_0_0;  // int32
  reg signed [31:0] Delay28_t_0_1;  // int32
  reg signed [31:0] Delay28_t_1;  // int32
  reg signed [31:0] Delay29_t_0_0;  // int32
  reg signed [31:0] Delay29_t_1;  // int32
  reg signed [31:0] Delay311_t_0_0;  // int32
  reg signed [31:0] Delay311_t_0_1;  // int32
  reg signed [31:0] Delay311_t_1;  // int32
  reg signed [31:0] Delay7_t_0_0;  // int32
  reg signed [31:0] Delay7_t_0_1;  // int32
  reg signed [31:0] Delay7_t_1;  // int32
  reg signed [31:0] Delay2_t_0_0;  // int32
  reg signed [31:0] Delay2_t_1;  // int32
  reg signed [31:0] Delay13_t_0_0;  // int32
  reg signed [31:0] Delay13_t_1;  // int32
  reg signed [31:0] HwModeRegister_t_0_0;  // int32
  reg signed [31:0] HwModeRegister_t_0_1;  // int32
  reg signed [31:0] HwModeRegister_t_1;  // int32
  reg signed [31:0] rd_11_t_0_0;  // int32
  reg signed [31:0] rd_11_t_1;  // int32
  reg signed [31:0] reduced_t_0_0;  // int32
  reg signed [31:0] reduced_t_1;  // int32
  reg signed [31:0] HwModeRegister_t_0_0_1;  // int32
  reg signed [31:0] HwModeRegister_t_0_1_1;  // int32
  reg signed [31:0] HwModeRegister_t_1_1;  // int32
  reg signed [31:0] reduced_t_0_0_1;  // int32
  reg signed [31:0] reduced_t_1_1;  // int32
  reg signed [31:0] Delay1_t_0_0;  // int32
  reg signed [31:0] Delay1_t_1;  // int32


  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        freq_1 <= 34'sh000000000;
      end
      else begin
        if (enb_1_8_0) begin
          freq_1 <= freq;
        end
      end
    end

  assign Delay11_out1 = freq_1;

  always @(posedge clk or posedge reset)
    begin : Delay241_output_process
      if (reset == 1'b1) begin
        Delay11_out1_1 <= 34'sh000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Delay11_out1_1 <= Delay11_out1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay28_process
      if (reset == 1'b1) begin
        for(Delay28_t_1 = 32'sd0; Delay28_t_1 <= 32'sd7; Delay28_t_1 = Delay28_t_1 + 32'sd1) begin
          Delay28_reg[Delay28_t_1] <= 34'sh000000000;
        end
      end
      else begin
        if (enb_1_8_0) begin
          for(Delay28_t_0_1 = 32'sd0; Delay28_t_0_1 <= 32'sd7; Delay28_t_0_1 = Delay28_t_0_1 + 32'sd1) begin
            Delay28_reg[Delay28_t_0_1] <= Delay28_reg_next[Delay28_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay28_out1 = Delay28_reg[7];
    Delay28_reg_next[0] = Delay11_out1_1;

    for(Delay28_t_0_0 = 32'sd0; Delay28_t_0_0 <= 32'sd6; Delay28_t_0_0 = Delay28_t_0_0 + 32'sd1) begin
      Delay28_reg_next[Delay28_t_0_0 + 32'sd1] = Delay28_reg[Delay28_t_0_0];
    end

  end

  assign Delay28_out1_1 = Delay28_out1;

  always @(posedge clk or posedge reset)
    begin : Delay291_output_process
      if (reset == 1'b1) begin
        Delay28_out1_2 <= 34'sh000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Delay28_out1_2 <= Delay28_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay29_process
      if (reset == 1'b1) begin
        for(Delay29_t_1 = 32'sd0; Delay29_t_1 <= 32'sd1; Delay29_t_1 = Delay29_t_1 + 32'sd1) begin
          Delay29_reg[Delay29_t_1] <= 34'sh000000000;
        end
      end
      else begin
        if (enb_1_8_0) begin
          for(Delay29_t_0_0 = 32'sd0; Delay29_t_0_0 <= 32'sd1; Delay29_t_0_0 = Delay29_t_0_0 + 32'sd1) begin
            Delay29_reg[Delay29_t_0_0] <= Delay29_reg_next[Delay29_t_0_0];
          end
        end
      end
    end

  assign Delay29_out1 = Delay29_reg[1];
  assign Delay29_reg_next[0] = Delay28_out1_2;
  assign Delay29_reg_next[1] = Delay29_reg[0];

  assign Delay29_out1_1 = Delay29_out1;

  always @(posedge clk or posedge reset)
    begin : Delay301_output_process
      if (reset == 1'b1) begin
        Delay29_out1_2 <= 34'sh000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Delay29_out1_2 <= Delay29_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay311_process
      if (reset == 1'b1) begin
        for(Delay311_t_1 = 32'sd0; Delay311_t_1 <= 32'sd2; Delay311_t_1 = Delay311_t_1 + 32'sd1) begin
          Delay311_reg[Delay311_t_1] <= 34'sh000000000;
        end
      end
      else begin
        if (enb_1_8_0) begin
          for(Delay311_t_0_1 = 32'sd0; Delay311_t_0_1 <= 32'sd2; Delay311_t_0_1 = Delay311_t_0_1 + 32'sd1) begin
            Delay311_reg[Delay311_t_0_1] <= Delay311_reg_next[Delay311_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay31_out1 = Delay311_reg[2];
    Delay311_reg_next[0] = Delay29_out1_2;

    for(Delay311_t_0_0 = 32'sd0; Delay311_t_0_0 <= 32'sd1; Delay311_t_0_0 = Delay311_t_0_0 + 32'sd1) begin
      Delay311_reg_next[Delay311_t_0_0 + 32'sd1] = Delay311_reg[Delay311_t_0_0];
    end

  end

  assign freqOut = Delay31_out1;

  always @(posedge clk or posedge reset)
    begin : Delay8_process
      if (reset == 1'b1) begin
        Delay8_out1_re <= 16'sb0000000000000000;
        Delay8_out1_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_8_0) begin
          Delay8_out1_re <= dataIn_re;
          Delay8_out1_im <= dataIn_im;
        end
      end
    end

  assign Delay8_out1_re_1 = Delay8_out1_re;

  assign Delay8_out1_im_1 = Delay8_out1_im;

  always @(posedge clk or posedge reset)
    begin : Delay91_output_process
      if (reset == 1'b1) begin
        Delay8_out1_re_2 <= 16'sb0000000000000000;
        Delay8_out1_im_2 <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Delay8_out1_re_2 <= Delay8_out1_re_1;
          Delay8_out1_im_2 <= Delay8_out1_im_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay7_process
      if (reset == 1'b1) begin
        for(Delay7_t_1 = 32'sd0; Delay7_t_1 <= 32'sd7; Delay7_t_1 = Delay7_t_1 + 32'sd1) begin
          Delay7_reg_re[Delay7_t_1] <= 16'sb0000000000000000;
          Delay7_reg_im[Delay7_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb_1_8_0) begin
          for(Delay7_t_0_1 = 32'sd0; Delay7_t_0_1 <= 32'sd7; Delay7_t_0_1 = Delay7_t_0_1 + 32'sd1) begin
            Delay7_reg_re[Delay7_t_0_1] <= Delay7_reg_next_re[Delay7_t_0_1];
            Delay7_reg_im[Delay7_t_0_1] <= Delay7_reg_next_im[Delay7_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay7_out1_re = Delay7_reg_re[7];
    Delay7_out1_im = Delay7_reg_im[7];
    Delay7_reg_next_re[0] = Delay8_out1_re_2;
    Delay7_reg_next_im[0] = Delay8_out1_im_2;

    for(Delay7_t_0_0 = 32'sd0; Delay7_t_0_0 <= 32'sd6; Delay7_t_0_0 = Delay7_t_0_0 + 32'sd1) begin
      Delay7_reg_next_re[Delay7_t_0_0 + 32'sd1] = Delay7_reg_re[Delay7_t_0_0];
      Delay7_reg_next_im[Delay7_t_0_0 + 32'sd1] = Delay7_reg_im[Delay7_t_0_0];
    end

  end

  assign Delay7_out1_re_1 = Delay7_out1_re;

  assign Delay7_out1_im_1 = Delay7_out1_im;

  always @(posedge clk or posedge reset)
    begin : DTConverter1_bypass_process
      if (reset == 1'b1) begin
        DTConverter1_bypass_reg_re <= 16'sb0000000000000000;
        DTConverter1_bypass_reg_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          DTConverter1_bypass_reg_im <= Delay7_out1_im_1;
          DTConverter1_bypass_reg_re <= Delay7_out1_re_1;
        end
      end
    end

  assign Delay7_out1_re_2 = (enb_1_8_1 == 1'b1 ? Delay7_out1_re_1 :
              DTConverter1_bypass_reg_re);
  assign Delay7_out1_im_2 = (enb_1_8_1 == 1'b1 ? Delay7_out1_im_1 :
              DTConverter1_bypass_reg_im);

  always @(posedge clk or posedge reset)
    begin : Delay22_output_process
      if (reset == 1'b1) begin
        Delay7_out1_re_3 <= 16'sb0000000000000000;
        Delay7_out1_im_3 <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Delay7_out1_re_3 <= Delay7_out1_re_1;
          Delay7_out1_im_3 <= Delay7_out1_im_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        for(Delay2_t_1 = 32'sd0; Delay2_t_1 <= 32'sd1; Delay2_t_1 = Delay2_t_1 + 32'sd1) begin
          Delay2_reg_re[Delay2_t_1] <= 16'sb0000000000000000;
          Delay2_reg_im[Delay2_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb_1_8_0) begin
          for(Delay2_t_0_0 = 32'sd0; Delay2_t_0_0 <= 32'sd1; Delay2_t_0_0 = Delay2_t_0_0 + 32'sd1) begin
            Delay2_reg_re[Delay2_t_0_0] <= Delay2_reg_next_re[Delay2_t_0_0];
            Delay2_reg_im[Delay2_t_0_0] <= Delay2_reg_next_im[Delay2_t_0_0];
          end
        end
      end
    end

  assign Delay2_out1_re = Delay2_reg_re[1];
  assign Delay2_out1_im = Delay2_reg_im[1];
  assign Delay2_reg_next_re[0] = Delay7_out1_re_3;
  assign Delay2_reg_next_im[0] = Delay7_out1_im_3;
  assign Delay2_reg_next_re[1] = Delay2_reg_re[0];
  assign Delay2_reg_next_im[1] = Delay2_reg_im[0];

  assign Delay2_out1_re_1 = Delay2_out1_re;

  assign Delay2_out1_im_1 = Delay2_out1_im;

  always @(posedge clk or posedge reset)
    begin : rd_01_process
      if (reset == 1'b1) begin
        Delay2_out1_re_2 <= 16'sb0000000000000000;
        Delay2_out1_im_2 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay2_out1_re_2 <= Delay2_out1_re_1;
          Delay2_out1_im_2 <= Delay2_out1_im_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : reduced_process
      if (reset == 1'b1) begin
        Product1_C2ReIm_1_C2ReIm_A <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Product1_C2ReIm_1_C2ReIm_A <= Delay2_out1_re_2;
        end
      end
    end

  assign Delay6_out1 = freq_1;

  assign Data_Type_Conversion1_out1 = {{17{Delay6_out1[33]}}, Delay6_out1[33:15]};

  always @(posedge clk or posedge reset)
    begin : rd_1_process
      if (reset == 1'b1) begin
        Data_Type_Conversion1_out1_1 <= 36'sh000000000;
      end
      else begin
        if (enb) begin
          Data_Type_Conversion1_out1_1 <= Data_Type_Conversion1_out1;
        end
      end
    end

  assign switch_compare_1 = Data_Type_Conversion1_out1_1 >= 36'sh000000000;

  assign Shift_Arithmetic_out1 = Data_Type_Conversion1_out1 <<< 8'd16;

  assign Abs_cast = {Shift_Arithmetic_out1[35], Shift_Arithmetic_out1};
  assign Abs_y = (Shift_Arithmetic_out1 < 36'sh000000000 ?  - (Abs_cast) :
              {Shift_Arithmetic_out1[35], Shift_Arithmetic_out1});
  assign Abs_out1 = Abs_y[35:0];

  assign Data_Type_Conversion_out1 = Abs_out1[33:18] + (Abs_out1[17] & (( ~ Abs_out1[35]) | (|Abs_out1[16:0])));

  always @(posedge clk or posedge reset)
    begin : NCO1_bypass_process
      if (reset == 1'b1) begin
        NCO1_bypass_reg <= 16'b0000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          NCO1_bypass_reg <= Data_Type_Conversion_out1;
        end
      end
    end

  assign Data_Type_Conversion_out1_1 = (enb_1_8_1 == 1'b1 ? Data_Type_Conversion_out1 :
              NCO1_bypass_reg);

  always @(posedge clk or posedge reset)
    begin : Delay12_process
      if (reset == 1'b1) begin
        Delay12_out1 <= 1'b0;
      end
      else begin
        if (enb_1_8_0) begin
          Delay12_out1 <= validIn;
        end
      end
    end

  assign Delay12_out1_1 = Delay12_out1;

  always @(posedge clk or posedge reset)
    begin : NCO2_bypass_process
      if (reset == 1'b1) begin
        NCO2_bypass_reg <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          NCO2_bypass_reg <= Delay12_out1_1;
        end
      end
    end

  assign Delay12_out1_2 = (enb_1_8_1 == 1'b1 ? Delay12_out1_1 :
              NCO2_bypass_reg);

  NCO u_NCO (.clk(clk),
             .reset(reset),
             .enb_1_8_0(enb_1_8_0),
             .inc(Data_Type_Conversion_out1_1),  // uint16
             .validIn(Delay12_out1_2),
             .complexexp_re(NCO_out1_re),  // sfix16_En14
             .complexexp_im(NCO_out1_im),  // sfix16_En14
             .validOut(NCO_out2)
             );

  always @(posedge clk or posedge reset)
    begin : Delay13_process
      if (reset == 1'b1) begin
        for(Delay13_t_1 = 32'sd0; Delay13_t_1 <= 32'sd1; Delay13_t_1 = Delay13_t_1 + 32'sd1) begin
          Delay13_reg_re[Delay13_t_1] <= 16'sb0000000000000000;
          Delay13_reg_im[Delay13_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb_1_8_0) begin
          for(Delay13_t_0_0 = 32'sd0; Delay13_t_0_0 <= 32'sd1; Delay13_t_0_0 = Delay13_t_0_0 + 32'sd1) begin
            Delay13_reg_re[Delay13_t_0_0] <= Delay13_reg_next_re[Delay13_t_0_0];
            Delay13_reg_im[Delay13_t_0_0] <= Delay13_reg_next_im[Delay13_t_0_0];
          end
        end
      end
    end

  assign Delay13_out1_re = Delay13_reg_re[1];
  assign Delay13_out1_im = Delay13_reg_im[1];
  assign Delay13_reg_next_re[0] = NCO_out1_re;
  assign Delay13_reg_next_im[0] = NCO_out1_im;
  assign Delay13_reg_next_re[1] = Delay13_reg_re[0];
  assign Delay13_reg_next_im[1] = Delay13_reg_im[0];

  assign Delay13_out1_re_1 = Delay13_out1_re;

  assign Delay13_out1_im_1 = Delay13_out1_im;

  always @(posedge clk or posedge reset)
    begin : rd_2_process
      if (reset == 1'b1) begin
        Delay13_out1_re_2 <= 16'sb0000000000000000;
        Delay13_out1_im_2 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay13_out1_re_2 <= Delay13_out1_re_1;
          Delay13_out1_im_2 <= Delay13_out1_im_1;
        end
      end
    end

  assign complexConjugate_out1_re = Delay13_out1_re_1;
  assign conj_cast = {Delay13_out1_im_1[15], Delay13_out1_im_1};
  assign conj_cast_1 =  - (conj_cast);
  assign complexConjugate_out1_im = ((conj_cast_1[16] == 1'b0) && (conj_cast_1[15] != 1'b0) ? 16'sb0111111111111111 :
              ((conj_cast_1[16] == 1'b1) && (conj_cast_1[15] != 1'b1) ? 16'sb1000000000000000 :
              $signed(conj_cast_1[15:0])));

  always @(posedge clk or posedge reset)
    begin : rd_0_process
      if (reset == 1'b1) begin
        complexConjugate_out1_re_1 <= 16'sb0000000000000000;
        complexConjugate_out1_im_1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          complexConjugate_out1_re_1 <= complexConjugate_out1_re;
          complexConjugate_out1_im_1 <= complexConjugate_out1_im;
        end
      end
    end

  assign Switch_out1_re = (switch_compare_1 == 1'b0 ? Delay13_out1_re_2 :
              complexConjugate_out1_re_1);
  assign Switch_out1_im = (switch_compare_1 == 1'b0 ? Delay13_out1_im_2 :
              complexConjugate_out1_im_1);

  always @(posedge clk or posedge reset)
    begin : crp_out_delay_process
      if (reset == 1'b1) begin
        Switch_out1_re_1 <= 16'sb0000000000000000;
        Switch_out1_im_1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Switch_out1_re_1 <= Switch_out1_re;
          Switch_out1_im_1 <= Switch_out1_im;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay31_output_process
      if (reset == 1'b1) begin
        Switch_out1_re_2 <= 16'sb0000000000000000;
        Switch_out1_im_2 <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Switch_out1_re_2 <= Switch_out1_re_1;
          Switch_out1_im_2 <= Switch_out1_im_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1_re <= 16'sb0000000000000000;
        Delay3_out1_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_8_0) begin
          Delay3_out1_re <= Switch_out1_re_2;
          Delay3_out1_im <= Switch_out1_im_2;
        end
      end
    end

  assign Delay3_out1_re_1 = Delay3_out1_re;

  assign Delay3_out1_im_1 = Delay3_out1_im;

  always @(posedge clk or posedge reset)
    begin : rd_21_process
      if (reset == 1'b1) begin
        Delay3_out1_re_2 <= 16'sb0000000000000000;
        Delay3_out1_im_2 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Delay3_out1_re_2 <= Delay3_out1_re_1;
          Delay3_out1_im_2 <= Delay3_out1_im_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : reduced_1_process
      if (reset == 1'b1) begin
        Product1_C2ReIm_2_C2ReIm_A <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Product1_C2ReIm_2_C2ReIm_A <= Delay3_out1_re_2;
        end
      end
    end

  assign Product1_Re_AC = Product1_C2ReIm_1_C2ReIm_A * Product1_C2ReIm_2_C2ReIm_A;

  always @(posedge clk or posedge reset)
    begin : HwModeRegister_process
      if (reset == 1'b1) begin
        for(HwModeRegister_t_1 = 32'sd0; HwModeRegister_t_1 <= 32'sd2; HwModeRegister_t_1 = HwModeRegister_t_1 + 32'sd1) begin
          HwModeRegister_reg[HwModeRegister_t_1] <= 32'sb00000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister_t_0_1 = 32'sd0; HwModeRegister_t_0_1 <= 32'sd2; HwModeRegister_t_0_1 = HwModeRegister_t_0_1 + 32'sd1) begin
            HwModeRegister_reg[HwModeRegister_t_0_1] <= HwModeRegister_reg_next[HwModeRegister_t_0_1];
          end
        end
      end
    end

  always @* begin
    Product1_Re_AC_1 = HwModeRegister_reg[2];
    HwModeRegister_reg_next[0] = Product1_Re_AC;

    for(HwModeRegister_t_0_0 = 32'sd0; HwModeRegister_t_0_0 <= 32'sd1; HwModeRegister_t_0_0 = HwModeRegister_t_0_0 + 32'sd1) begin
      HwModeRegister_reg_next[HwModeRegister_t_0_0 + 32'sd1] = HwModeRegister_reg[HwModeRegister_t_0_0];
    end

  end

  always @(posedge clk or posedge reset)
    begin : rd_11_process
      if (reset == 1'b1) begin
        for(rd_11_t_1 = 32'sd0; rd_11_t_1 <= 32'sd1; rd_11_t_1 = rd_11_t_1 + 32'sd1) begin
          rd_11_reg[rd_11_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_11_t_0_0 = 32'sd0; rd_11_t_0_0 <= 32'sd1; rd_11_t_0_0 = rd_11_t_0_0 + 32'sd1) begin
            rd_11_reg[rd_11_t_0_0] <= rd_11_reg_next[rd_11_t_0_0];
          end
        end
      end
    end

  assign Product1_C2ReIm_1_C2ReIm_B = rd_11_reg[1];
  assign rd_11_reg_next[0] = Delay2_out1_im_2;
  assign rd_11_reg_next[1] = rd_11_reg[0];

  always @(posedge clk or posedge reset)
    begin : reduced_2_process
      if (reset == 1'b1) begin
        Product1_C2ReIm_1_C2ReIm_B_1 <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Product1_C2ReIm_1_C2ReIm_B_1 <= Product1_C2ReIm_1_C2ReIm_B;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : reduced_3_process
      if (reset == 1'b1) begin
        Product1_C2ReIm_2_C2ReIm_B <= 16'sb0000000000000000;
      end
      else begin
        if (enb) begin
          Product1_C2ReIm_2_C2ReIm_B <= Delay3_out1_im_2;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : reduced_4_process
      if (reset == 1'b1) begin
        for(reduced_t_1 = 32'sd0; reduced_t_1 <= 32'sd1; reduced_t_1 = reduced_t_1 + 32'sd1) begin
          reduced_reg[reduced_t_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(reduced_t_0_0 = 32'sd0; reduced_t_0_0 <= 32'sd1; reduced_t_0_0 = reduced_t_0_0 + 32'sd1) begin
            reduced_reg[reduced_t_0_0] <= reduced_reg_next[reduced_t_0_0];
          end
        end
      end
    end

  assign Product1_C2ReIm_2_C2ReIm_B_1 = reduced_reg[1];
  assign reduced_reg_next[0] = Product1_C2ReIm_2_C2ReIm_B;
  assign reduced_reg_next[1] = reduced_reg[0];

  assign mulOutput = Product1_C2ReIm_1_C2ReIm_B_1 * Product1_C2ReIm_2_C2ReIm_B_1;

  always @(posedge clk or posedge reset)
    begin : HwModeRegister_1_process
      if (reset == 1'b1) begin
        mulOutput_1 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mulOutput_1 <= mulOutput;
        end
      end
    end

  assign MultiplyAdd_add_sub_cast = {Product1_Re_AC_1[31], Product1_Re_AC_1};
  assign MultiplyAdd_add_sub_cast_1 = {mulOutput_1[31], mulOutput_1};
  assign mulOutput_2 = MultiplyAdd_add_sub_cast - MultiplyAdd_add_sub_cast_1;

  assign Product1_Im_AD = Product1_C2ReIm_1_C2ReIm_A * Product1_C2ReIm_2_C2ReIm_B;

  always @(posedge clk or posedge reset)
    begin : HwModeRegister_2_process
      if (reset == 1'b1) begin
        for(HwModeRegister_t_1_1 = 32'sd0; HwModeRegister_t_1_1 <= 32'sd2; HwModeRegister_t_1_1 = HwModeRegister_t_1_1 + 32'sd1) begin
          HwModeRegister_reg_1[HwModeRegister_t_1_1] <= 32'sb00000000000000000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister_t_0_1_1 = 32'sd0; HwModeRegister_t_0_1_1 <= 32'sd2; HwModeRegister_t_0_1_1 = HwModeRegister_t_0_1_1 + 32'sd1) begin
            HwModeRegister_reg_1[HwModeRegister_t_0_1_1] <= HwModeRegister_reg_next_1[HwModeRegister_t_0_1_1];
          end
        end
      end
    end

  always @* begin
    Product1_Im_AD_1 = HwModeRegister_reg_1[2];
    HwModeRegister_reg_next_1[0] = Product1_Im_AD;

    for(HwModeRegister_t_0_0_1 = 32'sd0; HwModeRegister_t_0_0_1 <= 32'sd1; HwModeRegister_t_0_0_1 = HwModeRegister_t_0_0_1 + 32'sd1) begin
      HwModeRegister_reg_next_1[HwModeRegister_t_0_0_1 + 32'sd1] = HwModeRegister_reg_1[HwModeRegister_t_0_0_1];
    end

  end

  always @(posedge clk or posedge reset)
    begin : reduced_5_process
      if (reset == 1'b1) begin
        for(reduced_t_1_1 = 32'sd0; reduced_t_1_1 <= 32'sd1; reduced_t_1_1 = reduced_t_1_1 + 32'sd1) begin
          reduced_reg_1[reduced_t_1_1] <= 16'sb0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(reduced_t_0_0_1 = 32'sd0; reduced_t_0_0_1 <= 32'sd1; reduced_t_0_0_1 = reduced_t_0_0_1 + 32'sd1) begin
            reduced_reg_1[reduced_t_0_0_1] <= reduced_reg_next_1[reduced_t_0_0_1];
          end
        end
      end
    end

  assign Product1_C2ReIm_2_C2ReIm_A_1 = reduced_reg_1[1];
  assign reduced_reg_next_1[0] = Product1_C2ReIm_2_C2ReIm_A;
  assign reduced_reg_next_1[1] = reduced_reg_1[0];

  assign mulOutput_3 = Product1_C2ReIm_1_C2ReIm_B_1 * Product1_C2ReIm_2_C2ReIm_A_1;

  always @(posedge clk or posedge reset)
    begin : HwModeRegister_3_process
      if (reset == 1'b1) begin
        mulOutput_4 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          mulOutput_4 <= mulOutput_3;
        end
      end
    end

  assign MultiplyAdd1_add_add_cast = {Product1_Im_AD_1[31], Product1_Im_AD_1};
  assign MultiplyAdd1_add_add_cast_1 = {mulOutput_4[31], mulOutput_4};
  assign mulOutput_5 = MultiplyAdd1_add_add_cast + MultiplyAdd1_add_add_cast_1;

  always @(posedge clk or posedge reset)
    begin : HwModeRegister_4_process
      if (reset == 1'b1) begin
        mulOutput_6 <= 33'sh000000000;
      end
      else begin
        if (enb) begin
          mulOutput_6 <= mulOutput_2;
        end
      end
    end

  assign mulOutput_7 = mulOutput_6[31:0];

  always @(posedge clk or posedge reset)
    begin : HwModeRegister_5_process
      if (reset == 1'b1) begin
        mulOutput_8 <= 33'sh000000000;
      end
      else begin
        if (enb) begin
          mulOutput_8 <= mulOutput_5;
        end
      end
    end

  assign mulOutput_9 = mulOutput_8[31:0];

  always @(posedge clk or posedge reset)
    begin : crp_out_delay1_process
      if (reset == 1'b1) begin
        Product1_out1_re <= 32'sb00000000000000000000000000000000;
        Product1_out1_im <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb) begin
          Product1_out1_re <= mulOutput_7;
          Product1_out1_im <= mulOutput_9;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay41_output_process
      if (reset == 1'b1) begin
        Product1_out1_re_1 <= 32'sb00000000000000000000000000000000;
        Product1_out1_im_1 <= 32'sb00000000000000000000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Product1_out1_re_1 <= Product1_out1_re;
          Product1_out1_im_1 <= Product1_out1_im;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        for(Delay1_t_1 = 32'sd0; Delay1_t_1 <= 32'sd1; Delay1_t_1 = Delay1_t_1 + 32'sd1) begin
          Delay1_reg_re[Delay1_t_1] <= 32'sb00000000000000000000000000000000;
          Delay1_reg_im[Delay1_t_1] <= 32'sb00000000000000000000000000000000;
        end
      end
      else begin
        if (enb_1_8_0) begin
          for(Delay1_t_0_0 = 32'sd0; Delay1_t_0_0 <= 32'sd1; Delay1_t_0_0 = Delay1_t_0_0 + 32'sd1) begin
            Delay1_reg_re[Delay1_t_0_0] <= Delay1_reg_next_re[Delay1_t_0_0];
            Delay1_reg_im[Delay1_t_0_0] <= Delay1_reg_next_im[Delay1_t_0_0];
          end
        end
      end
    end

  assign Delay1_out1_re = Delay1_reg_re[1];
  assign Delay1_out1_im = Delay1_reg_im[1];
  assign Delay1_reg_next_re[0] = Product1_out1_re_1;
  assign Delay1_reg_next_im[0] = Product1_out1_im_1;
  assign Delay1_reg_next_re[1] = Delay1_reg_re[0];
  assign Delay1_reg_next_im[1] = Delay1_reg_im[0];

  DTConverter u_DTConverter (.dataIn1_re(Delay7_out1_re_2),  // sfix16_En12
                             .dataIn1_im(Delay7_out1_im_2),  // sfix16_En12
                             .dataIn2_re(Delay1_out1_re),  // sfix32_En26
                             .dataIn2_im(Delay1_out1_im),  // sfix32_En26
                             .dataOut_re(dataOut_re),  // sfix16_En12
                             .dataOut_im(dataOut_im)  // sfix16_En12
                             );

  always @(posedge clk or posedge reset)
    begin : Delay14_process
      if (reset == 1'b1) begin
        Delay14_reg <= {2{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay14_reg[0] <= NCO_out2;
          Delay14_reg[1] <= Delay14_reg[0];
        end
      end
    end

  assign Delay14_out1 = Delay14_reg[1];

  assign Delay14_out1_1 = Delay14_out1;

  always @(posedge clk or posedge reset)
    begin : Delay151_output_process
      if (reset == 1'b1) begin
        Delay14_out1_2 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay14_out1_2 <= Delay14_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay15_process
      if (reset == 1'b1) begin
        Delay15_reg <= {2{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay15_reg[0] <= Delay14_out1_2;
          Delay15_reg[1] <= Delay15_reg[0];
        end
      end
    end

  assign Delay15_out1 = Delay15_reg[1];

  assign Delay15_out1_1 = Delay15_out1;

  always @(posedge clk or posedge reset)
    begin : Delay161_output_process
      if (reset == 1'b1) begin
        Delay15_out1_2 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay15_out1_2 <= Delay15_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay17_process
      if (reset == 1'b1) begin
        Delay17_reg <= {3{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay17_reg[0] <= Delay15_out1_2;
          Delay17_reg[32'sd2:32'sd1] <= Delay17_reg[32'sd1:32'sd0];
        end
      end
    end

  assign Delay17_out1 = Delay17_reg[2];

  assign validOut = Delay17_out1;

  always @(posedge clk or posedge reset)
    begin : Delay18_process
      if (reset == 1'b1) begin
        Delay18_out1 <= 1'b0;
      end
      else begin
        if (enb_1_8_0) begin
          Delay18_out1 <= lstfStartIn;
        end
      end
    end

  assign Delay18_out1_1 = Delay18_out1;

  always @(posedge clk or posedge reset)
    begin : Delay251_output_process
      if (reset == 1'b1) begin
        Delay18_out1_2 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay18_out1_2 <= Delay18_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay20_process
      if (reset == 1'b1) begin
        Delay20_reg <= {8{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay20_reg[0] <= Delay18_out1_2;
          Delay20_reg[32'sd7:32'sd1] <= Delay20_reg[32'sd6:32'sd0];
        end
      end
    end

  assign Delay20_out1 = Delay20_reg[7];

  assign Delay20_out1_1 = Delay20_out1;

  always @(posedge clk or posedge reset)
    begin : Delay211_output_process
      if (reset == 1'b1) begin
        Delay20_out1_2 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay20_out1_2 <= Delay20_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay21_process
      if (reset == 1'b1) begin
        Delay21_reg <= {2{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay21_reg[0] <= Delay20_out1_2;
          Delay21_reg[1] <= Delay21_reg[0];
        end
      end
    end

  assign Delay21_out1 = Delay21_reg[1];

  assign Delay21_out1_1 = Delay21_out1;

  always @(posedge clk or posedge reset)
    begin : Delay222_output_process
      if (reset == 1'b1) begin
        Delay21_out1_2 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay21_out1_2 <= Delay21_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay23_process
      if (reset == 1'b1) begin
        Delay23_reg <= {3{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay23_reg[0] <= Delay21_out1_2;
          Delay23_reg[32'sd2:32'sd1] <= Delay23_reg[32'sd1:32'sd0];
        end
      end
    end

  assign Delay23_out1 = Delay23_reg[2];

  assign lstfStartOut = Delay23_out1;

  assign rstOut = rstIn;

endmodule  // Coarse_CFO_Correction

