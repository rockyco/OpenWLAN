// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/wlanhdlTimeAndFrequencySynchronization/magnitudeSquared_block1.v
// Created: 2026-02-04 22:38:43
// 
// Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: magnitudeSquared_block1
// Source Path: wlanhdlTimeAndFrequencySynchronization/WLANTimeAndFrequencySynchronization/Coarse Time Sync/Energy 
// Calculator/magnitudeSquare
// Hierarchy Level: 3
// Model version: 9.2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module magnitudeSquared_block1
          (clk,
           reset,
           enb_1_8_1,
           enb_1_8_0,
           enb,
           dataIn_re,
           dataIn_im,
           validIn,
           energy,
           push);


  input   clk;
  input   reset;
  input   enb_1_8_1;
  input   enb_1_8_0;
  input   enb;
  input   signed [15:0] dataIn_re;  // sfix16_En12
  input   signed [15:0] dataIn_im;  // sfix16_En12
  input   validIn;
  output  signed [70:0] energy;  // sfix71_En54
  output  push;


  wire signed [32:0] out;  // sfix33_En27
  wire MagnitudeSquared_validOut;
  reg signed [32:0] out_1;  // sfix33_En27
  reg signed [32:0] Delay3_bypass_reg;  // sfix33
  wire signed [32:0] Delay3_out1;  // sfix33_En27
  wire signed [32:0] Delay3_out1_1;  // sfix33_En27
  reg signed [32:0] Delay3_out1_2;  // sfix33_En27
  reg signed [32:0] Delay_reg [0:15];  // sfix33 [16]
  reg signed [32:0] Delay_reg_next [0:15];  // sfix33_En27 [16]
  reg signed [32:0] Delay_out1;  // sfix33_En27
  wire signed [32:0] Delay_out1_1;  // sfix33_En27
  reg signed [32:0] Delay_out1_2;  // sfix33_En27
  wire signed [33:0] Add_add_cast;  // sfix34_En27
  wire signed [33:0] Add_add_cast_1;  // sfix34_En27
  wire signed [33:0] Add_out1;  // sfix34_En27
  reg signed [33:0] Add_out1_1;  // sfix34_En27
  wire signed [33:0] Shift_Arithmetic_out1;  // sfix34_En27
  reg  Delay4_out1;
  wire Delay4_out1_1;
  reg  Delay4_out1_2;
  reg  [15:0] Delay1_reg;  // ufix1 [16]
  wire Delay1_out1;
  wire signed [34:0] MovingSum_dataOut;  // sfix35_En27
  wire MovingSum_validOut;
  wire signed [34:0] MovingSum_dataOut_1;  // sfix35_En27
  reg signed [34:0] MovingSum_dataOut_2;  // sfix35_En27
  wire signed [34:0] Shift_Arithmetic1_out1;  // sfix35_En27
  wire MovingSum_validOut_1;
  reg  MovingSum_validOut_2;
  reg  [14:0] Delay2_reg;  // ufix1 [15]
  wire Delay2_out1;
  wire signed [70:0] MagnitudeSquared1_dataOut;  // sfix71_En54
  wire MagnitudeSquared1_validOut;
  reg signed [70:0] MagnitudeSquared1_dataOut_1;  // sfix71_En54
  wire signed [70:0] Shift_Arithmetic2_out1;  // sfix71_En54
  reg signed [31:0] Delay_t_0_0;  // int32
  reg signed [31:0] Delay_t_0_1;  // int32
  reg signed [31:0] Delay_t_1;  // int32


  MagnitudeSquared_block u_MagnitudeSquared (.clk(clk),
                                             .reset(reset),
                                             .enb_1_8_1(enb_1_8_1),
                                             .enb_1_8_0(enb_1_8_0),
                                             .enb(enb),
                                             .dataIn_re(dataIn_re),  // sfix16_En12
                                             .dataIn_im(dataIn_im),  // sfix16_En12
                                             .validIn(validIn),
                                             .dataOut(out),  // sfix33_En27
                                             .validOut(MagnitudeSquared_validOut)
                                             );

  always @(posedge clk or posedge reset)
    begin : crp_out_delay_process
      if (reset == 1'b1) begin
        out_1 <= 33'sh000000000;
      end
      else begin
        if (enb) begin
          out_1 <= out;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay3_bypass_process
      if (reset == 1'b1) begin
        Delay3_bypass_reg <= 33'sh000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Delay3_bypass_reg <= out_1;
        end
      end
    end

  assign Delay3_out1 = (enb_1_8_1 == 1'b1 ? out_1 :
              Delay3_bypass_reg);

  assign Delay3_out1_1 = Delay3_out1;

  always @(posedge clk or posedge reset)
    begin : rd_1_process
      if (reset == 1'b1) begin
        Delay3_out1_2 <= 33'sh000000000;
      end
      else begin
        if (enb) begin
          Delay3_out1_2 <= Delay3_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        for(Delay_t_1 = 32'sd0; Delay_t_1 <= 32'sd15; Delay_t_1 = Delay_t_1 + 32'sd1) begin
          Delay_reg[Delay_t_1] <= 33'sh000000000;
        end
      end
      else begin
        if (enb_1_8_0) begin
          for(Delay_t_0_1 = 32'sd0; Delay_t_0_1 <= 32'sd15; Delay_t_0_1 = Delay_t_0_1 + 32'sd1) begin
            Delay_reg[Delay_t_0_1] <= Delay_reg_next[Delay_t_0_1];
          end
        end
      end
    end

  always @* begin
    Delay_out1 = Delay_reg[15];
    Delay_reg_next[0] = Delay3_out1;

    for(Delay_t_0_0 = 32'sd0; Delay_t_0_0 <= 32'sd14; Delay_t_0_0 = Delay_t_0_0 + 32'sd1) begin
      Delay_reg_next[Delay_t_0_0 + 32'sd1] = Delay_reg[Delay_t_0_0];
    end

  end

  assign Delay_out1_1 = Delay_out1;

  always @(posedge clk or posedge reset)
    begin : rd_2_process
      if (reset == 1'b1) begin
        Delay_out1_2 <= 33'sh000000000;
      end
      else begin
        if (enb) begin
          Delay_out1_2 <= Delay_out1_1;
        end
      end
    end

  assign Add_add_cast = {Delay3_out1_2[32], Delay3_out1_2};
  assign Add_add_cast_1 = {Delay_out1_2[32], Delay_out1_2};
  assign Add_out1 = Add_add_cast + Add_add_cast_1;

  always @(posedge clk or posedge reset)
    begin : rd_3_process
      if (reset == 1'b1) begin
        Add_out1_1 <= 34'sh000000000;
      end
      else begin
        if (enb) begin
          Add_out1_1 <= Add_out1;
        end
      end
    end

  assign Shift_Arithmetic_out1 = Add_out1_1 >>> 8'd1;

  always @(posedge clk or posedge reset)
    begin : Delay4_process
      if (reset == 1'b1) begin
        Delay4_out1 <= 1'b0;
      end
      else begin
        if (enb_1_8_0) begin
          Delay4_out1 <= MagnitudeSquared_validOut;
        end
      end
    end

  assign Delay4_out1_1 = Delay4_out1;

  always @(posedge clk or posedge reset)
    begin : Delay11_output_process
      if (reset == 1'b1) begin
        Delay4_out1_2 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay4_out1_2 <= Delay4_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_reg <= {16{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay1_reg[0] <= Delay4_out1_2;
          Delay1_reg[32'sd15:32'sd1] <= Delay1_reg[32'sd14:32'sd0];
        end
      end
    end

  assign Delay1_out1 = Delay1_reg[15];

  MovingSum_block u_MovingSum (.clk(clk),
                               .reset(reset),
                               .enb_1_8_1(enb_1_8_1),
                               .enb_1_8_0(enb_1_8_0),
                               .enb(enb),
                               .dataIn(Shift_Arithmetic_out1),  // sfix34_En27
                               .validIn(Delay1_out1),
                               .dataOut(MovingSum_dataOut),  // sfix35_En27
                               .validOut(MovingSum_validOut)
                               );

  assign MovingSum_dataOut_1 = MovingSum_dataOut;

  always @(posedge clk or posedge reset)
    begin : rd_11_process
      if (reset == 1'b1) begin
        MovingSum_dataOut_2 <= 35'sh000000000;
      end
      else begin
        if (enb) begin
          MovingSum_dataOut_2 <= MovingSum_dataOut_1;
        end
      end
    end

  assign Shift_Arithmetic1_out1 = MovingSum_dataOut_2 >>> 8'd4;

  assign MovingSum_validOut_1 = MovingSum_validOut;

  always @(posedge clk or posedge reset)
    begin : Delay21_output_process
      if (reset == 1'b1) begin
        MovingSum_validOut_2 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          MovingSum_validOut_2 <= MovingSum_validOut_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_reg <= {15{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay2_reg[0] <= MovingSum_validOut_2;
          Delay2_reg[32'sd14:32'sd1] <= Delay2_reg[32'sd13:32'sd0];
        end
      end
    end

  assign Delay2_out1 = Delay2_reg[14];

  MagnitudeSquared1 u_MagnitudeSquared1 (.clk(clk),
                                         .reset(reset),
                                         .enb_1_8_1(enb_1_8_1),
                                         .enb_1_8_0(enb_1_8_0),
                                         .enb(enb),
                                         .dataIn(Shift_Arithmetic1_out1),  // sfix35_En27
                                         .validIn(Delay2_out1),
                                         .dataOut(MagnitudeSquared1_dataOut),  // sfix71_En54
                                         .validOut(MagnitudeSquared1_validOut)
                                         );

  always @(posedge clk or posedge reset)
    begin : rd_0_process
      if (reset == 1'b1) begin
        MagnitudeSquared1_dataOut_1 <= 71'sh000000000000000000;
      end
      else begin
        if (enb) begin
          MagnitudeSquared1_dataOut_1 <= MagnitudeSquared1_dataOut;
        end
      end
    end

  assign Shift_Arithmetic2_out1 = MagnitudeSquared1_dataOut_1 >>> 8'd1;

  assign energy = Shift_Arithmetic2_out1;

  assign push = MagnitudeSquared1_validOut;

endmodule  // magnitudeSquared_block1

