// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/wlanhdlTimeAndFrequencySynchronization/MagnitudeSquared1.v
// Created: 2026-02-04 22:38:43
// 
// Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: MagnitudeSquared1
// Source Path: wlanhdlTimeAndFrequencySynchronization/WLANTimeAndFrequencySynchronization/Coarse Time Sync/Energy 
// Calculator/magnitudeSquared/MagnitudeSquared
// Hierarchy Level: 4
// Model version: 9.2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module MagnitudeSquared1
          (clk,
           reset,
           enb_1_8_1,
           enb_1_8_0,
           enb,
           dataIn,
           validIn,
           dataOut,
           validOut);


  input   clk;
  input   reset;
  input   enb_1_8_1;
  input   enb_1_8_0;
  input   enb;
  input   signed [34:0] dataIn;  // sfix35_En27
  input   validIn;
  output  signed [70:0] dataOut;  // sfix71_En54
  output  validOut;


  wire signed [34:0] Complex_to_Real_Imag_out1;  // sfix35_En27
  wire signed [34:0] Complex_to_Real_Imag_out2;  // sfix35_En27
  reg signed [34:0] Complex_to_Real_Imag_out1_1;  // sfix35_En27
  reg signed [34:0] Complex_to_Real_Imag_out1_2;  // sfix35_En27
  reg signed [34:0] Delay1_out1;  // sfix35_En27
  wire signed [34:0] Delay1_out1_1;  // sfix35_En27
  reg signed [34:0] HwModeRegister_reg [0:1];  // sfix35 [2]
  wire signed [34:0] HwModeRegister_reg_next [0:1];  // sfix35_En27 [2]
  wire signed [34:0] Delay1_out1_2;  // sfix35_En27
  reg signed [34:0] Complex_to_Real_Imag_out1_3;  // sfix35_En27
  reg signed [34:0] Delay_out1;  // sfix35_En27
  wire signed [34:0] Delay_out1_1;  // sfix35_En27
  reg signed [34:0] HwModeRegister1_reg [0:1];  // sfix35 [2]
  wire signed [34:0] HwModeRegister1_reg_next [0:1];  // sfix35_En27 [2]
  wire signed [34:0] Delay_out1_2;  // sfix35_En27
  wire signed [69:0] Product4_out1;  // sfix70_En54
  reg signed [69:0] crp_out_delay_reg [0:1];  // sfix70 [2]
  wire signed [69:0] crp_out_delay_reg_next [0:1];  // sfix70_En54 [2]
  wire signed [69:0] Product4_out1_1;  // sfix70_En54
  reg signed [69:0] Delay41_bypass_reg;  // sfix70
  wire signed [69:0] Delay4_out1;  // sfix70_En54
  wire signed [69:0] Delay4_out1_1;  // sfix70_En54
  reg signed [69:0] Delay4_out1_2;  // sfix70_En54
  reg signed [34:0] Complex_to_Real_Imag_out2_1;  // sfix35_En27
  reg signed [34:0] Complex_to_Real_Imag_out2_2;  // sfix35_En27
  reg signed [34:0] Delay2_out1;  // sfix35_En27
  wire signed [34:0] Delay2_out1_1;  // sfix35_En27
  reg signed [34:0] HwModeRegister2_reg [0:1];  // sfix35 [2]
  wire signed [34:0] HwModeRegister2_reg_next [0:1];  // sfix35_En27 [2]
  wire signed [34:0] Delay2_out1_2;  // sfix35_En27
  reg signed [34:0] Complex_to_Real_Imag_out2_3;  // sfix35_En27
  reg signed [34:0] Delay3_out1;  // sfix35_En27
  wire signed [34:0] Delay3_out1_1;  // sfix35_En27
  reg signed [34:0] HwModeRegister3_reg [0:1];  // sfix35 [2]
  wire signed [34:0] HwModeRegister3_reg_next [0:1];  // sfix35_En27 [2]
  wire signed [34:0] Delay3_out1_2;  // sfix35_En27
  wire signed [69:0] Product1_out1;  // sfix70_En54
  reg signed [69:0] crp_out_delay1_reg [0:1];  // sfix70 [2]
  wire signed [69:0] crp_out_delay1_reg_next [0:1];  // sfix70_En54 [2]
  wire signed [69:0] Product1_out1_1;  // sfix70_En54
  reg signed [69:0] Delay5_bypass_reg;  // sfix70
  wire signed [69:0] Delay5_out1;  // sfix70_En54
  wire signed [69:0] Delay5_out1_1;  // sfix70_En54
  reg signed [69:0] Delay5_out1_2;  // sfix70_En54
  wire signed [70:0] Add_add_cast;  // sfix71_En54
  wire signed [70:0] Add_add_cast_1;  // sfix71_En54
  wire signed [70:0] Add_out1;  // sfix71_En54
  wire validIn_1;
  reg  validIn_2;
  reg  [2:0] Delay6_reg;  // ufix1 [3]
  wire Delay6_out1;
  reg signed [31:0] HwModeRegister_t_0_0;  // int32
  reg signed [31:0] HwModeRegister_t_1;  // int32
  reg signed [31:0] HwModeRegister1_t_0_0;  // int32
  reg signed [31:0] HwModeRegister1_t_1;  // int32
  reg signed [31:0] crp_out_delay_t_0_0;  // int32
  reg signed [31:0] crp_out_delay_t_1;  // int32
  reg signed [31:0] HwModeRegister2_t_0_0;  // int32
  reg signed [31:0] HwModeRegister2_t_1;  // int32
  reg signed [31:0] HwModeRegister3_t_0_0;  // int32
  reg signed [31:0] HwModeRegister3_t_1;  // int32
  reg signed [31:0] crp_out_delay1_t_0_0;  // int32
  reg signed [31:0] crp_out_delay1_t_1;  // int32


  assign Complex_to_Real_Imag_out1 = dataIn;
  assign Complex_to_Real_Imag_out2 = 35'sh000000000;

  always @(posedge clk or posedge reset)
    begin : crp_out_delay2_process
      if (reset == 1'b1) begin
        Complex_to_Real_Imag_out1_1 <= 35'sh000000000;
      end
      else begin
        if (enb) begin
          Complex_to_Real_Imag_out1_1 <= Complex_to_Real_Imag_out1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay11_output_process
      if (reset == 1'b1) begin
        Complex_to_Real_Imag_out1_2 <= 35'sh000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Complex_to_Real_Imag_out1_2 <= Complex_to_Real_Imag_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay1_process
      if (reset == 1'b1) begin
        Delay1_out1 <= 35'sh000000000;
      end
      else begin
        if (enb_1_8_0) begin
          Delay1_out1 <= Complex_to_Real_Imag_out1_2;
        end
      end
    end

  assign Delay1_out1_1 = Delay1_out1;

  always @(posedge clk or posedge reset)
    begin : HwModeRegister_process
      if (reset == 1'b1) begin
        for(HwModeRegister_t_1 = 32'sd0; HwModeRegister_t_1 <= 32'sd1; HwModeRegister_t_1 = HwModeRegister_t_1 + 32'sd1) begin
          HwModeRegister_reg[HwModeRegister_t_1] <= 35'sh000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister_t_0_0 = 32'sd0; HwModeRegister_t_0_0 <= 32'sd1; HwModeRegister_t_0_0 = HwModeRegister_t_0_0 + 32'sd1) begin
            HwModeRegister_reg[HwModeRegister_t_0_0] <= HwModeRegister_reg_next[HwModeRegister_t_0_0];
          end
        end
      end
    end

  assign Delay1_out1_2 = HwModeRegister_reg[1];
  assign HwModeRegister_reg_next[0] = Delay1_out1_1;
  assign HwModeRegister_reg_next[1] = HwModeRegister_reg[0];

  always @(posedge clk or posedge reset)
    begin : Delay4_output_process
      if (reset == 1'b1) begin
        Complex_to_Real_Imag_out1_3 <= 35'sh000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Complex_to_Real_Imag_out1_3 <= Complex_to_Real_Imag_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay_process
      if (reset == 1'b1) begin
        Delay_out1 <= 35'sh000000000;
      end
      else begin
        if (enb_1_8_0) begin
          Delay_out1 <= Complex_to_Real_Imag_out1_3;
        end
      end
    end

  assign Delay_out1_1 = Delay_out1;

  always @(posedge clk or posedge reset)
    begin : HwModeRegister1_process
      if (reset == 1'b1) begin
        for(HwModeRegister1_t_1 = 32'sd0; HwModeRegister1_t_1 <= 32'sd1; HwModeRegister1_t_1 = HwModeRegister1_t_1 + 32'sd1) begin
          HwModeRegister1_reg[HwModeRegister1_t_1] <= 35'sh000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister1_t_0_0 = 32'sd0; HwModeRegister1_t_0_0 <= 32'sd1; HwModeRegister1_t_0_0 = HwModeRegister1_t_0_0 + 32'sd1) begin
            HwModeRegister1_reg[HwModeRegister1_t_0_0] <= HwModeRegister1_reg_next[HwModeRegister1_t_0_0];
          end
        end
      end
    end

  assign Delay_out1_2 = HwModeRegister1_reg[1];
  assign HwModeRegister1_reg_next[0] = Delay_out1_1;
  assign HwModeRegister1_reg_next[1] = HwModeRegister1_reg[0];

  assign Product4_out1 = Delay1_out1_2 * Delay_out1_2;

  always @(posedge clk or posedge reset)
    begin : crp_out_delay_process
      if (reset == 1'b1) begin
        for(crp_out_delay_t_1 = 32'sd0; crp_out_delay_t_1 <= 32'sd1; crp_out_delay_t_1 = crp_out_delay_t_1 + 32'sd1) begin
          crp_out_delay_reg[crp_out_delay_t_1] <= 70'sh000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(crp_out_delay_t_0_0 = 32'sd0; crp_out_delay_t_0_0 <= 32'sd1; crp_out_delay_t_0_0 = crp_out_delay_t_0_0 + 32'sd1) begin
            crp_out_delay_reg[crp_out_delay_t_0_0] <= crp_out_delay_reg_next[crp_out_delay_t_0_0];
          end
        end
      end
    end

  assign Product4_out1_1 = crp_out_delay_reg[1];
  assign crp_out_delay_reg_next[0] = Product4_out1;
  assign crp_out_delay_reg_next[1] = crp_out_delay_reg[0];

  always @(posedge clk or posedge reset)
    begin : Delay41_bypass_process
      if (reset == 1'b1) begin
        Delay41_bypass_reg <= 70'sh000000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Delay41_bypass_reg <= Product4_out1_1;
        end
      end
    end

  assign Delay4_out1 = (enb_1_8_1 == 1'b1 ? Product4_out1_1 :
              Delay41_bypass_reg);

  assign Delay4_out1_1 = Delay4_out1;

  always @(posedge clk or posedge reset)
    begin : rd_1_process
      if (reset == 1'b1) begin
        Delay4_out1_2 <= 70'sh000000000000000000;
      end
      else begin
        if (enb) begin
          Delay4_out1_2 <= Delay4_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : crp_out_delay3_process
      if (reset == 1'b1) begin
        Complex_to_Real_Imag_out2_1 <= 35'sh000000000;
      end
      else begin
        if (enb) begin
          Complex_to_Real_Imag_out2_1 <= Complex_to_Real_Imag_out2;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay21_output_process
      if (reset == 1'b1) begin
        Complex_to_Real_Imag_out2_2 <= 35'sh000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Complex_to_Real_Imag_out2_2 <= Complex_to_Real_Imag_out2_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay2_process
      if (reset == 1'b1) begin
        Delay2_out1 <= 35'sh000000000;
      end
      else begin
        if (enb_1_8_0) begin
          Delay2_out1 <= Complex_to_Real_Imag_out2_2;
        end
      end
    end

  assign Delay2_out1_1 = Delay2_out1;

  always @(posedge clk or posedge reset)
    begin : HwModeRegister2_process
      if (reset == 1'b1) begin
        for(HwModeRegister2_t_1 = 32'sd0; HwModeRegister2_t_1 <= 32'sd1; HwModeRegister2_t_1 = HwModeRegister2_t_1 + 32'sd1) begin
          HwModeRegister2_reg[HwModeRegister2_t_1] <= 35'sh000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister2_t_0_0 = 32'sd0; HwModeRegister2_t_0_0 <= 32'sd1; HwModeRegister2_t_0_0 = HwModeRegister2_t_0_0 + 32'sd1) begin
            HwModeRegister2_reg[HwModeRegister2_t_0_0] <= HwModeRegister2_reg_next[HwModeRegister2_t_0_0];
          end
        end
      end
    end

  assign Delay2_out1_2 = HwModeRegister2_reg[1];
  assign HwModeRegister2_reg_next[0] = Delay2_out1_1;
  assign HwModeRegister2_reg_next[1] = HwModeRegister2_reg[0];

  always @(posedge clk or posedge reset)
    begin : Delay31_output_process
      if (reset == 1'b1) begin
        Complex_to_Real_Imag_out2_3 <= 35'sh000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Complex_to_Real_Imag_out2_3 <= Complex_to_Real_Imag_out2_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay3_process
      if (reset == 1'b1) begin
        Delay3_out1 <= 35'sh000000000;
      end
      else begin
        if (enb_1_8_0) begin
          Delay3_out1 <= Complex_to_Real_Imag_out2_3;
        end
      end
    end

  assign Delay3_out1_1 = Delay3_out1;

  always @(posedge clk or posedge reset)
    begin : HwModeRegister3_process
      if (reset == 1'b1) begin
        for(HwModeRegister3_t_1 = 32'sd0; HwModeRegister3_t_1 <= 32'sd1; HwModeRegister3_t_1 = HwModeRegister3_t_1 + 32'sd1) begin
          HwModeRegister3_reg[HwModeRegister3_t_1] <= 35'sh000000000;
        end
      end
      else begin
        if (enb) begin
          for(HwModeRegister3_t_0_0 = 32'sd0; HwModeRegister3_t_0_0 <= 32'sd1; HwModeRegister3_t_0_0 = HwModeRegister3_t_0_0 + 32'sd1) begin
            HwModeRegister3_reg[HwModeRegister3_t_0_0] <= HwModeRegister3_reg_next[HwModeRegister3_t_0_0];
          end
        end
      end
    end

  assign Delay3_out1_2 = HwModeRegister3_reg[1];
  assign HwModeRegister3_reg_next[0] = Delay3_out1_1;
  assign HwModeRegister3_reg_next[1] = HwModeRegister3_reg[0];

  assign Product1_out1 = Delay2_out1_2 * Delay3_out1_2;

  always @(posedge clk or posedge reset)
    begin : crp_out_delay1_process
      if (reset == 1'b1) begin
        for(crp_out_delay1_t_1 = 32'sd0; crp_out_delay1_t_1 <= 32'sd1; crp_out_delay1_t_1 = crp_out_delay1_t_1 + 32'sd1) begin
          crp_out_delay1_reg[crp_out_delay1_t_1] <= 70'sh000000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(crp_out_delay1_t_0_0 = 32'sd0; crp_out_delay1_t_0_0 <= 32'sd1; crp_out_delay1_t_0_0 = crp_out_delay1_t_0_0 + 32'sd1) begin
            crp_out_delay1_reg[crp_out_delay1_t_0_0] <= crp_out_delay1_reg_next[crp_out_delay1_t_0_0];
          end
        end
      end
    end

  assign Product1_out1_1 = crp_out_delay1_reg[1];
  assign crp_out_delay1_reg_next[0] = Product1_out1;
  assign crp_out_delay1_reg_next[1] = crp_out_delay1_reg[0];

  always @(posedge clk or posedge reset)
    begin : Delay5_bypass_process
      if (reset == 1'b1) begin
        Delay5_bypass_reg <= 70'sh000000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Delay5_bypass_reg <= Product1_out1_1;
        end
      end
    end

  assign Delay5_out1 = (enb_1_8_1 == 1'b1 ? Product1_out1_1 :
              Delay5_bypass_reg);

  assign Delay5_out1_1 = Delay5_out1;

  always @(posedge clk or posedge reset)
    begin : rd_2_process
      if (reset == 1'b1) begin
        Delay5_out1_2 <= 70'sh000000000000000000;
      end
      else begin
        if (enb) begin
          Delay5_out1_2 <= Delay5_out1_1;
        end
      end
    end

  assign Add_add_cast = {Delay4_out1_2[69], Delay4_out1_2};
  assign Add_add_cast_1 = {Delay5_out1_2[69], Delay5_out1_2};
  assign Add_out1 = Add_add_cast + Add_add_cast_1;

  assign dataOut = Add_out1;

  assign validIn_1 = validIn;

  always @(posedge clk or posedge reset)
    begin : Delay61_output_process
      if (reset == 1'b1) begin
        validIn_2 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          validIn_2 <= validIn_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay6_process
      if (reset == 1'b1) begin
        Delay6_reg <= {3{1'b0}};
      end
      else begin
        if (enb_1_8_0) begin
          Delay6_reg[0] <= validIn_2;
          Delay6_reg[32'sd2:32'sd1] <= Delay6_reg[32'sd1:32'sd0];
        end
      end
    end

  assign Delay6_out1 = Delay6_reg[2];

  assign validOut = Delay6_out1;

endmodule  // MagnitudeSquared1

