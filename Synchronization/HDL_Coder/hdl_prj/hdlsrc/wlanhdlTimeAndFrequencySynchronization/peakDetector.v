// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/wlanhdlTimeAndFrequencySynchronization/peakDetector.v
// Created: 2026-02-04 22:38:44
// 
// Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: peakDetector
// Source Path: wlanhdlTimeAndFrequencySynchronization/WLANTimeAndFrequencySynchronization/Fine Time Sync/Peak Searcher/peakDetector
// Hierarchy Level: 3
// Model version: 9.2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module peakDetector
          (clk,
           reset,
           enb_1_8_1,
           enb_1_8_0,
           enb,
           maxPeakVal,
           counterRst,
           dataIn_re,
           dataIn_im,
           validIn,
           lstfStart,
           validOut,
           dataOut_re,
           dataOut_im);


  input   clk;
  input   reset;
  input   enb_1_8_1;
  input   enb_1_8_0;
  input   enb;
  input   [15:0] maxPeakVal;  // uint16
  input   counterRst;
  input   signed [15:0] dataIn_re;  // sfix16_En12
  input   signed [15:0] dataIn_im;  // sfix16_En12
  input   validIn;
  output  lstfStart;
  output  validOut;
  output  signed [15:0] dataOut_re;  // sfix16_En12
  output  signed [15:0] dataOut_im;  // sfix16_En12


  wire [15:0] maxPeakVal_1;  // uint16
  reg [15:0] maxPeakVal_2;  // uint16
  wire counterRst_1;
  reg  [3:0] rd_4_reg;  // ufix1 [4]
  wire counterRst_2;
  wire validIn_1;
  reg  [2:0] rd_5_reg;  // ufix1 [3]
  wire validIn_2;
  wire [15:0] count_step;  // uint16
  wire [15:0] count_from;  // uint16
  wire [15:0] count_reset;  // uint16
  reg [15:0] HDL_Counter2_out1;  // uint16
  wire [15:0] count;  // uint16
  reg [15:0] count_1;  // uint16
  wire need_to_wrap;
  reg  need_to_wrap_1;
  wire [15:0] count_value;  // uint16
  reg [15:0] count_value_1;  // uint16
  wire [15:0] HDL_Counter2_out1_1;  // uint16
  wire [15:0] HDL_Counter2_out1_2;  // uint16
  reg [15:0] rd_6_reg [0:1];  // ufix16 [2]
  wire [15:0] rd_6_reg_next [0:1];  // ufix16 [2]
  wire [15:0] HDL_Counter2_out1_3;  // uint16
  wire [15:0] count_2;  // uint16
  reg [15:0] count_3;  // uint16
  wire [15:0] count_4;  // uint16
  reg [15:0] count_5;  // uint16
  reg [15:0] HDL_Counter2_bypass_reg;  // ufix16
  reg [15:0] Delay17_bypass_reg;  // ufix16
  wire [15:0] Delay17_out1;  // uint16
  wire [15:0] Delay17_out1_1;  // uint16
  reg [15:0] Delay18_out1;  // uint16
  wire [15:0] Delay18_out1_1;  // uint16
  wire Relational_Operator_out1;
  reg  validIn_3;
  reg  Delay21_out1;
  wire Delay21_out1_1;
  wire Logical_Operator4_out1;
  reg  Logical_Operator4_out1_1;
  reg  Logical_Operator6_out1;
  reg  Delay12_bypass_reg;  // ufix1
  wire Delay12_out1;
  wire Delay12_out1_1;
  reg  Delay12_out1_2;
  wire Logical_Operator6_out1_1;
  reg  Delay10_bypass_reg;  // ufix1
  wire Delay10_out1;
  wire Delay10_out1_1;
  reg  Delay10_out1_2;
  wire Logical_Operator7_out1;
  reg  Logical_Operator7_out1_1;
  reg  Delay11_bypass_reg;  // ufix1
  wire Delay11_out1;
  wire Delay11_out1_1;
  reg  Delay11_out1_2;
  wire Switch_out1;
  wire Logical_Operator2_out1;
  reg  Logical_Operator2_out1_1;
  reg  Delay7_bypass_reg;  // ufix1
  wire Delay7_out1;
  wire Delay7_out1_1;
  wire Logical_Operator3_out1;
  reg  dataSelector_3_bypass_reg;  // ufix1
  wire Logical_Operator3_out1_1;
  wire signed [15:0] dataIn_re_1;  // sfix16_En12
  wire signed [15:0] dataIn_im_1;  // sfix16_En12
  reg signed [15:0] dataIn_re_2;  // sfix16_En12
  reg signed [15:0] dataIn_im_2;  // sfix16_En12
  reg signed [15:0] Delay20_out1_re;  // sfix16_En12
  reg signed [15:0] Delay20_out1_im;  // sfix16_En12
  wire signed [15:0] Delay20_out1_re_1;  // sfix16_En12
  wire signed [15:0] Delay20_out1_im_1;  // sfix16_En12
  reg signed [15:0] dataSelector_1_bypass_reg_re;  // sfix16_En12
  reg signed [15:0] dataSelector_1_bypass_reg_im;  // sfix16_En12
  wire signed [15:0] Delay20_out1_re_2;  // sfix16_En12
  wire signed [15:0] Delay20_out1_im_2;  // sfix16_En12
  reg  dataSelector_2_bypass_reg;  // ufix1
  wire Delay21_out1_2;
  wire signed [15:0] dataSelector_out1_re;  // sfix16_En12
  wire signed [15:0] dataSelector_out1_im;  // sfix16_En12
  reg signed [31:0] rd_6_t_0_0;  // int32
  reg signed [31:0] rd_6_t_1;  // int32


  assign maxPeakVal_1 = maxPeakVal;

  always @(posedge clk or posedge reset)
    begin : crp_out_delay_process
      if (reset == 1'b1) begin
        maxPeakVal_2 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          maxPeakVal_2 <= maxPeakVal_1;
        end
      end
    end

  assign counterRst_1 = counterRst;

  always @(posedge clk or posedge reset)
    begin : rd_4_process
      if (reset == 1'b1) begin
        rd_4_reg <= {4{1'b0}};
      end
      else begin
        if (enb) begin
          rd_4_reg[0] <= counterRst_1;
          rd_4_reg[32'sd3:32'sd1] <= rd_4_reg[32'sd2:32'sd0];
        end
      end
    end

  assign counterRst_2 = rd_4_reg[3];

  assign validIn_1 = validIn;

  always @(posedge clk or posedge reset)
    begin : rd_5_process
      if (reset == 1'b1) begin
        rd_5_reg <= {3{1'b0}};
      end
      else begin
        if (enb) begin
          rd_5_reg[0] <= validIn_1;
          rd_5_reg[32'sd2:32'sd1] <= rd_5_reg[32'sd1:32'sd0];
        end
      end
    end

  assign validIn_2 = rd_5_reg[2];

  // Count limited, Unsigned Counter
  //  initial value   = 0
  //  step value      = 1
  //  count to value  = 65535
  assign count_step = 16'b0000000000000001;

  assign count_from = 16'b0000000000000000;

  assign count_reset = 16'b0000000000000000;

  assign count = HDL_Counter2_out1 + count_step;

  always @(posedge clk or posedge reset)
    begin : rd_8_process
      if (reset == 1'b1) begin
        count_1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_1 <= count;
        end
      end
    end

  assign need_to_wrap = HDL_Counter2_out1 == 16'b1111111111111111;

  always @(posedge clk or posedge reset)
    begin : rd_7_process
      if (reset == 1'b1) begin
        need_to_wrap_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          need_to_wrap_1 <= need_to_wrap;
        end
      end
    end

  assign count_value = (need_to_wrap_1 == 1'b0 ? count_1 :
              count_from);

  always @(posedge clk or posedge reset)
    begin : rd_9_process
      if (reset == 1'b1) begin
        count_value_1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_value_1 <= count_value;
        end
      end
    end

  assign HDL_Counter2_out1_2 = HDL_Counter2_out1_1;

  always @(posedge clk or posedge reset)
    begin : rd_3_process
      if (reset == 1'b1) begin
        HDL_Counter2_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          HDL_Counter2_out1 <= HDL_Counter2_out1_2;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : rd_6_process
      if (reset == 1'b1) begin
        for(rd_6_t_1 = 32'sd0; rd_6_t_1 <= 32'sd1; rd_6_t_1 = rd_6_t_1 + 32'sd1) begin
          rd_6_reg[rd_6_t_1] <= 16'b0000000000000000;
        end
      end
      else begin
        if (enb) begin
          for(rd_6_t_0_0 = 32'sd0; rd_6_t_0_0 <= 32'sd1; rd_6_t_0_0 = rd_6_t_0_0 + 32'sd1) begin
            rd_6_reg[rd_6_t_0_0] <= rd_6_reg_next[rd_6_t_0_0];
          end
        end
      end
    end

  assign HDL_Counter2_out1_3 = rd_6_reg[1];
  assign rd_6_reg_next[0] = HDL_Counter2_out1;
  assign rd_6_reg_next[1] = rd_6_reg[0];

  assign count_2 = (validIn_2 == 1'b0 ? HDL_Counter2_out1_3 :
              count_value_1);

  always @(posedge clk or posedge reset)
    begin : rd_10_process
      if (reset == 1'b1) begin
        count_3 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_3 <= count_2;
        end
      end
    end

  assign count_4 = (counterRst_2 == 1'b0 ? count_3 :
              count_reset);

  always @(posedge clk or posedge reset)
    begin : crp_out_delay1_process
      if (reset == 1'b1) begin
        count_5 <= 16'b0000000000000000;
      end
      else begin
        if (enb) begin
          count_5 <= count_4;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : HDL_Counter2_bypass_process
      if (reset == 1'b1) begin
        HDL_Counter2_bypass_reg <= 16'b0000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          HDL_Counter2_bypass_reg <= count_5;
        end
      end
    end

  assign HDL_Counter2_out1_1 = (enb_1_8_1 == 1'b1 ? count_5 :
              HDL_Counter2_bypass_reg);

  always @(posedge clk or posedge reset)
    begin : Delay17_bypass_process
      if (reset == 1'b1) begin
        Delay17_bypass_reg <= 16'b0000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          Delay17_bypass_reg <= maxPeakVal_2;
        end
      end
    end

  assign Delay17_out1 = (enb_1_8_1 == 1'b1 ? maxPeakVal_2 :
              Delay17_bypass_reg);

  assign Delay17_out1_1 = Delay17_out1;

  always @(posedge clk or posedge reset)
    begin : Delay18_process
      if (reset == 1'b1) begin
        Delay18_out1 <= 16'b0000000000000000;
      end
      else begin
        if (enb_1_8_0) begin
          Delay18_out1 <= HDL_Counter2_out1_1;
        end
      end
    end

  assign Delay18_out1_1 = Delay18_out1;

  assign Relational_Operator_out1 = Delay17_out1_1 == Delay18_out1_1;

  always @(posedge clk or posedge reset)
    begin : Delay211_output_process
      if (reset == 1'b1) begin
        validIn_3 <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          validIn_3 <= validIn_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay21_process
      if (reset == 1'b1) begin
        Delay21_out1 <= 1'b0;
      end
      else begin
        if (enb_1_8_0) begin
          Delay21_out1 <= validIn_3;
        end
      end
    end

  assign Delay21_out1_1 = Delay21_out1;

  assign Logical_Operator4_out1 = Relational_Operator_out1 & Delay21_out1_1;

  always @(posedge clk or posedge reset)
    begin : rd_31_process
      if (reset == 1'b1) begin
        Logical_Operator4_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Logical_Operator4_out1_1 <= Logical_Operator4_out1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay12_bypass_process
      if (reset == 1'b1) begin
        Delay12_bypass_reg <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay12_bypass_reg <= Logical_Operator6_out1;
        end
      end
    end

  assign Delay12_out1 = (enb_1_8_1 == 1'b1 ? Logical_Operator6_out1 :
              Delay12_bypass_reg);

  assign Delay12_out1_1 = Delay12_out1;

  always @(posedge clk or posedge reset)
    begin : rd_51_process
      if (reset == 1'b1) begin
        Delay12_out1_2 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay12_out1_2 <= Delay12_out1_1;
        end
      end
    end

  assign Logical_Operator6_out1_1 = Logical_Operator4_out1_1 | Delay12_out1_2;

  always @(posedge clk or posedge reset)
    begin : crp_out_delay4_process
      if (reset == 1'b1) begin
        Logical_Operator6_out1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Logical_Operator6_out1 <= Logical_Operator6_out1_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay10_bypass_process
      if (reset == 1'b1) begin
        Delay10_bypass_reg <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay10_bypass_reg <= Logical_Operator6_out1;
        end
      end
    end

  assign Delay10_out1 = (enb_1_8_1 == 1'b1 ? Logical_Operator6_out1 :
              Delay10_bypass_reg);

  assign Delay10_out1_1 = Delay10_out1;

  always @(posedge clk or posedge reset)
    begin : rd_2_process
      if (reset == 1'b1) begin
        Delay10_out1_2 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay10_out1_2 <= Delay10_out1_1;
        end
      end
    end

  assign Logical_Operator7_out1 = Delay10_out1_2 & Logical_Operator4_out1_1;

  always @(posedge clk or posedge reset)
    begin : crp_out_delay3_process
      if (reset == 1'b1) begin
        Logical_Operator7_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Logical_Operator7_out1_1 <= Logical_Operator7_out1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay11_bypass_process
      if (reset == 1'b1) begin
        Delay11_bypass_reg <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay11_bypass_reg <= Logical_Operator7_out1_1;
        end
      end
    end

  assign Delay11_out1 = (enb_1_8_1 == 1'b1 ? Logical_Operator7_out1_1 :
              Delay11_bypass_reg);

  assign Delay11_out1_1 = Delay11_out1;

  always @(posedge clk or posedge reset)
    begin : rd_1_process
      if (reset == 1'b1) begin
        Delay11_out1_2 <= 1'b0;
      end
      else begin
        if (enb) begin
          Delay11_out1_2 <= Delay11_out1_1;
        end
      end
    end

  assign Switch_out1 = (Delay10_out1_2 == 1'b0 ? Logical_Operator4_out1_1 :
              Delay11_out1_2);

  assign lstfStart = Switch_out1;

  always @(posedge clk or posedge reset)
    begin : crp_out_delay2_process
      if (reset == 1'b1) begin
        Logical_Operator2_out1_1 <= 1'b0;
      end
      else begin
        if (enb) begin
          Logical_Operator2_out1_1 <= Logical_Operator2_out1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay7_bypass_process
      if (reset == 1'b1) begin
        Delay7_bypass_reg <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          Delay7_bypass_reg <= Logical_Operator2_out1_1;
        end
      end
    end

  assign Delay7_out1 = (enb_1_8_1 == 1'b1 ? Logical_Operator2_out1_1 :
              Delay7_bypass_reg);

  assign Delay7_out1_1 = Delay7_out1;

  assign Logical_Operator2_out1 = Logical_Operator4_out1 | Delay7_out1_1;

  assign Logical_Operator3_out1 = Logical_Operator2_out1 & Delay21_out1_1;

  assign validOut = Logical_Operator3_out1;

  always @(posedge clk or posedge reset)
    begin : dataSelector_3_bypass_process
      if (reset == 1'b1) begin
        dataSelector_3_bypass_reg <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          dataSelector_3_bypass_reg <= Logical_Operator3_out1;
        end
      end
    end

  assign Logical_Operator3_out1_1 = (enb_1_8_1 == 1'b1 ? Logical_Operator3_out1 :
              dataSelector_3_bypass_reg);

  assign dataIn_re_1 = dataIn_re;

  assign dataIn_im_1 = dataIn_im;

  always @(posedge clk or posedge reset)
    begin : Delay201_output_process
      if (reset == 1'b1) begin
        dataIn_re_2 <= 16'sb0000000000000000;
        dataIn_im_2 <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          dataIn_re_2 <= dataIn_re_1;
          dataIn_im_2 <= dataIn_im_1;
        end
      end
    end

  always @(posedge clk or posedge reset)
    begin : Delay20_process
      if (reset == 1'b1) begin
        Delay20_out1_re <= 16'sb0000000000000000;
        Delay20_out1_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_8_0) begin
          Delay20_out1_re <= dataIn_re_2;
          Delay20_out1_im <= dataIn_im_2;
        end
      end
    end

  assign Delay20_out1_re_1 = Delay20_out1_re;

  assign Delay20_out1_im_1 = Delay20_out1_im;

  always @(posedge clk or posedge reset)
    begin : dataSelector_1_bypass_process
      if (reset == 1'b1) begin
        dataSelector_1_bypass_reg_re <= 16'sb0000000000000000;
        dataSelector_1_bypass_reg_im <= 16'sb0000000000000000;
      end
      else begin
        if (enb_1_8_1) begin
          dataSelector_1_bypass_reg_im <= Delay20_out1_im_1;
          dataSelector_1_bypass_reg_re <= Delay20_out1_re_1;
        end
      end
    end

  assign Delay20_out1_re_2 = (enb_1_8_1 == 1'b1 ? Delay20_out1_re_1 :
              dataSelector_1_bypass_reg_re);
  assign Delay20_out1_im_2 = (enb_1_8_1 == 1'b1 ? Delay20_out1_im_1 :
              dataSelector_1_bypass_reg_im);

  always @(posedge clk or posedge reset)
    begin : dataSelector_2_bypass_process
      if (reset == 1'b1) begin
        dataSelector_2_bypass_reg <= 1'b0;
      end
      else begin
        if (enb_1_8_1) begin
          dataSelector_2_bypass_reg <= Delay21_out1_1;
        end
      end
    end

  assign Delay21_out1_2 = (enb_1_8_1 == 1'b1 ? Delay21_out1_1 :
              dataSelector_2_bypass_reg);

  MATLAB_Function1 u_dataSelector (.syncEn(Logical_Operator3_out1_1),
                                   .dataIn_re(Delay20_out1_re_2),  // sfix16_En12
                                   .dataIn_im(Delay20_out1_im_2),  // sfix16_En12
                                   .validIn(Delay21_out1_2),
                                   .dataOut_re(dataSelector_out1_re),  // sfix16_En12
                                   .dataOut_im(dataSelector_out1_im)  // sfix16_En12
                                   );

  assign dataOut_re = dataSelector_out1_re;

  assign dataOut_im = dataSelector_out1_im;

endmodule  // peakDetector

