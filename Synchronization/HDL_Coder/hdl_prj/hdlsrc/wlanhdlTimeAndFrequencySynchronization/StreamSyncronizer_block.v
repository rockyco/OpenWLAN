// -------------------------------------------------------------
// 
// File Name: hdl_prj/hdlsrc/wlanhdlTimeAndFrequencySynchronization/StreamSyncronizer_block.v
// Created: 2026-02-04 22:38:43
// 
// Generated by MATLAB 25.1, HDL Coder 25.1, and Simulink 25.1
// 
// -------------------------------------------------------------


// -------------------------------------------------------------
// 
// Module: StreamSyncronizer_block
// Source Path: wlanhdlTimeAndFrequencySynchronization/WLANTimeAndFrequencySynchronization/Coarse Time Sync/Stream 
// Synchronizer/StreamSyncronize
// Hierarchy Level: 3
// Model version: 9.2
// 
// -------------------------------------------------------------

`timescale 1 ns / 1 ns

module StreamSyncronizer_block
          (clk,
           reset,
           enb_1_8_0,
           pop,
           dataIn_re,
           dataIn_im,
           push,
           dataOut_re,
           dataOut_im,
           validOut);


  input   clk;
  input   reset;
  input   enb_1_8_0;
  input   pop;
  input   signed [15:0] dataIn_re;  // sfix16_En12
  input   signed [15:0] dataIn_im;  // sfix16_En12
  input   push;
  output  signed [15:0] dataOut_re;  // sfix16_En12
  output  signed [15:0] dataOut_im;  // sfix16_En12
  output  validOut;


  reg signed [15:0] dataOut_re_1;  // sfix16_En12
  reg signed [15:0] dataOut_im_1;  // sfix16_En12
  reg  validOut_1;
  reg [7:0] wrAddr;  // ufix8
  reg [7:0] rdAddr;  // ufix8
  reg signed [15:0] dataOutReg_re;  // sfix16_En12
  reg signed [15:0] dataOutReg_im;  // sfix16_En12
  reg  validOutReg;
  reg signed [15:0] mem_re [0:255];  // sfix16_En12 [256]
  reg signed [15:0] mem_im [0:255];  // sfix16_En12 [256]
  reg signed [15:0] level;  // int16
  reg [7:0] wrAddr_next;  // ufix8
  reg [7:0] rdAddr_next;  // ufix8
  reg signed [15:0] dataOutReg_next_re;  // sfix16_En12
  reg signed [15:0] dataOutReg_next_im;  // sfix16_En12
  reg  validOutReg_next;
  reg signed [15:0] mem_next_re [0:255];  // sfix16_En12 [256]
  reg signed [15:0] mem_next_im [0:255];  // sfix16_En12 [256]
  reg signed [15:0] level_next;  // int16
  reg signed [15:0] level_temp;  // int16
  reg signed [31:0] t_0;  // int32
  reg signed [16:0] sub_temp;  // sfix17
  reg signed [16:0] add_temp;  // sfix17
  reg signed [16:0] t_1;  // sfix17
  reg signed [16:0] t_2;  // sfix17
  reg signed [31:0] t_0_0;  // int32
  reg signed [31:0] t_1_0;  // int32


  always @(posedge clk or posedge reset)
    begin : StreamSyncronizer_process
      if (reset == 1'b1) begin
        wrAddr <= 8'b00000000;
        rdAddr <= 8'b00000000;
        dataOutReg_re <= 16'sb0000000000000000;
        dataOutReg_im <= 16'sb0000000000000000;
        validOutReg <= 1'b0;

        for(t_1_0 = 32'sd0; t_1_0 <= 32'sd255; t_1_0 = t_1_0 + 32'sd1) begin
          mem_re[t_1_0] <= 16'sb0000000000000000;
          mem_im[t_1_0] <= 16'sb0000000000000000;
        end

        level <= 16'sd0;
      end
      else begin
        if (enb_1_8_0) begin
          wrAddr <= wrAddr_next;
          rdAddr <= rdAddr_next;
          dataOutReg_re <= dataOutReg_next_re;
          dataOutReg_im <= dataOutReg_next_im;
          validOutReg <= validOutReg_next;

          for(t_0_0 = 32'sd0; t_0_0 <= 32'sd255; t_0_0 = t_0_0 + 32'sd1) begin
            mem_re[t_0_0] <= mem_next_re[t_0_0];
            mem_im[t_0_0] <= mem_next_im[t_0_0];
          end

          level <= level_next;
        end
      end
    end

  always @* begin
    sub_temp = 17'sb00000000000000000;
    add_temp = 17'sb00000000000000000;
    t_1 = 17'sb00000000000000000;
    t_2 = 17'sb00000000000000000;
    level_temp = level;
    wrAddr_next = wrAddr;
    rdAddr_next = rdAddr;
    dataOutReg_next_re = dataOutReg_re;
    dataOutReg_next_im = dataOutReg_im;

    for(t_0 = 32'sd0; t_0 <= 32'sd255; t_0 = t_0 + 32'sd1) begin
      mem_next_re[t_0] = mem_re[t_0];
      mem_next_im[t_0] = mem_im[t_0];
    end

    //------------------------------------------------------------------------
    // Constants
    //------------------------------------------------------------------------
    // Persistent variable initialization
    //------------------------------------------------------------------------
    // Outputs
    //------------------------------------------------------------------------
    //------------------------------------------------------------------------
    // Calculate next state values
    //------------------------------------------------------------------------
    if (pop) begin
      dataOutReg_next_re = mem_re[rdAddr];
      dataOutReg_next_im = mem_im[rdAddr];
      rdAddr_next = rdAddr + 8'b00000001;
      t_1 = {level[15], level};
      sub_temp = t_1 - 17'sb00000000000000001;
      if ((sub_temp[16] == 1'b0) && (sub_temp[15] != 1'b0)) begin
        level_temp = 16'sb0111111111111111;
      end
      else if ((sub_temp[16] == 1'b1) && (sub_temp[15] != 1'b1)) begin
        level_temp = 16'sb1000000000000000;
      end
      else begin
        level_temp = sub_temp[15:0];
      end
    end
    if (push) begin
      mem_next_re[wrAddr] = dataIn_re;
      mem_next_im[wrAddr] = dataIn_im;
      wrAddr_next = wrAddr + 8'b00000001;
      t_2 = {level_temp[15], level_temp};
      add_temp = t_2 + 17'sb00000000000000001;
      if ((add_temp[16] == 1'b0) && (add_temp[15] != 1'b0)) begin
        level_temp = 16'sb0111111111111111;
      end
      else if ((add_temp[16] == 1'b1) && (add_temp[15] != 1'b1)) begin
        level_temp = 16'sb1000000000000000;
      end
      else begin
        level_temp = add_temp[15:0];
      end
    end
    validOutReg_next = pop;
    dataOut_re_1 = dataOutReg_re;
    dataOut_im_1 = dataOutReg_im;
    validOut_1 = validOutReg;
    level_next = level_temp;
  end

  assign dataOut_re = dataOut_re_1;

  assign dataOut_im = dataOut_im_1;

  assign validOut = validOut_1;

endmodule  // StreamSyncronizer_block

